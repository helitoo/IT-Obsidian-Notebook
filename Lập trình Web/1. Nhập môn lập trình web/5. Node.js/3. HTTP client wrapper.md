
```insta-toc
---
title:
  name: Mục lục
  level: 1
  center: false
exclude: ""
style:
  listType: number
omit: []
levels:
  min: 1
  max: 6
---

# Mục lục

1. Định nghĩa kiểu dữ liệu
    1. Kiểu options tự định nghĩa
    2. Kiểu nội dung Error
    3. Kiểu error
2. Xây dựng hàm fetch API
    1. Main request
    2. Wrapper
```

Trên thực tế, cú pháp của fetch API của JS khá dài và tốn sức, ta có thể gom gọn chúng như sau.

Khởi tạo một HTTP client `http` với các method `.get`, `.post`,... tiện ích. Nó tự động:
	1. Authorization.
	2. Hiệu chỉnh URL.
	3. Xử lý lỗi:
		1. `401 Unauthorized`: Đăng xuất và điều hướng đến `/login`.
		2. `422 Unprocessable Entity`: Ném ra lỗi.

(Các code sau có thể định nghĩa tại `/lib/http-client.ts`).

>[!note]
>Code sau xây dựng Authorization bằng cách lưu token vào **Local Storage**. Đối với cách dùng [[3.3. JWT-Cookie-based Authentication|Cookie]] thì mọi chuyện sẽ đơn giản hơn vì HTTP hỗ trợ đính kèm cookie vào request.

# Định nghĩa kiểu dữ liệu

## Kiểu options tự định nghĩa

```ts
type CustomOptions = Omit<RequestInit, 'method'> & {
  baseUrl?: string | undefined
}
```
- `RequestInit` là kiểu của `fetch()`.
- `CustomOptions` là kế thừa từ `RequestInit`, đồng thời:
	- Loại bỏ `method` vì ta sẽ tự thêm nó trong `request` sau.
	- Thêm `baseUrl` để hỗ trợ hiệu chỉnh URL.

## Kiểu nội dung Error

```ts
type EntityErrorPayload = {
  message: string
  errors: {
    field: string
    message: string
  }[]
}
```

## Kiểu error

```ts
export class HttpError extends Error {
  status: number
  
  payload: {
    message: string
    [key: string]: any
  }
  
  constructor({ status, payload }: { status: number; payload: any }) {
    super('Http Error')
    this.status = status
    this.payload = payload
  }
}
```

Lớp riêng để xử lý mã lỗi `422 Unprocessable content`.

```ts
export class EntityError extends HttpError {
  status: 422
  
  payload: EntityErrorPayload
  
  constructor({
    status,
    payload
  }: {
    status: 422
    payload: EntityErrorPayload
  }) {
    super({ status, payload })
    this.status = status
    this.payload = payload
  }
}
```

# Xây dựng hàm fetch API

## Main request

```ts
let clientLogoutRequest: null | Promise<any> = null
export const isClient = () => typeof window !== 'undefined'

const request = async <Response>(
  method: 'GET' | 'POST' | 'PUT' | 'DELETE',
  url: string,
  options?: CustomOptions | undefined
) => {

  // Hiệu chỉnh body
  
  let body: FormData | string | undefined = undefined
  
  if (options?.body instanceof FormData)
    body = options.body
  else if (options?.body)
    body = JSON.stringify(options.body)
  
  // Hiệu chỉnh Content-type
  
  const baseHeaders: {
    [key: string]: string
  } =
    body instanceof FormData
      ? {} // Browser tự thêm 'multipart/form-data'...
      : {
          'Content-Type': 'application/json'
        }
  
  // Thêm session token vào header
  
  if (isClient()) {
    const sessionToken = localStorage.getItem('sessionToken')
    if (sessionToken)
      baseHeaders.Authorization = `Bearer ${sessionToken}`
  }
  
  // Hiệu chỉnh URL, coi '/abc/def' và 'abc/def' là một

  const baseUrl =
    options?.baseUrl === undefined
      ? process.env.NEXT_PUBLIC_API_ENDPOINT
      : options.baseUrl

  const fullUrl = url.startsWith('/') ? `${baseUrl}${url}` : `${baseUrl}/${url}`

  // Request

  const res = await fetch(fullUrl, {
    ...options,
    headers: {
      ...baseHeaders,
      ...options?.headers
    } as any,
    body,
    method
  })
  
  // Hiệu chỉnh response
  
  const payload: Response = await res.json()
  
  const data = {
    status: res.status,
    payload
  }
  
  // Xử lý error
  
  if (!res.ok) {
    if (res.status === 422) {
      throw new EntityError(
        data as {
          status: 422
          payload: EntityErrorPayload
        }
      )
    } else if (res.status === 401) {
      // Ở client
      if (isClient()) {
        if (!clientLogoutRequest) {
          clientLogoutRequest = fetch('/api/auth/logout', {
            method: 'POST',
            body: JSON.stringify({ force: true }),
            headers: {
              ...baseHeaders
            } as any
          })
          try {
            await clientLogoutRequest
          } catch (error) {
          } finally {
            localStorage.removeItem('sessionToken')
            localStorage.removeItem('sessionTokenExpiresAt')
            clientLogoutRequest = null
            location.href = '/login'
          }
        }
      }
      // Ở server
      else {
        const sessionToken = (options?.headers as any)?.Authorization.split(
          'Bearer '
        )[1]
        redirect(`/logout?sessionToken=${sessionToken}`)
      }
    } else {
      throw new HttpError(data)
    }
  }
  // TH login / register
  if (isClient()) {
    if (
      ['auth/login', 'auth/register'].some(
        (item) => item === normalizePath(url)
      )
    ) {
      const { token, expiresAt } = (payload as LoginResType).data
      localStorage.setItem('sessionToken', token)
      localStorage.setItem('sessionTokenExpiresAt', expiresAt)
    } else if ('auth/logout' === normalizePath(url)) {
      localStorage.removeItem('sessionToken')
      localStorage.removeItem('sessionTokenExpiresAt')
    }
  }
  return data
```

## Wrapper

```ts
const http = {
  get<Response>(
    url: string,
    options?: Omit<CustomOptions, 'body'> | undefined
  ) {
    return request<Response>('GET', url, options)
  },
  
  post<Response>(
    url: string,
    body: any,
    options?: Omit<CustomOptions, 'body'> | undefined
  ) {
    return request<Response>('POST', url, { ...options, body })
  },
  
  put<Response>(
    url: string,
    body: any,
    options?: Omit<CustomOptions, 'body'> | undefined
  ) {
    return request<Response>('PUT', url, { ...options, body })
  },
  
  delete<Response>(
    url: string,
    options?: Omit<CustomOptions, 'body'> | undefined
  ) {
    return request<Response>('DELETE', url, { ...options })
  }
}

export default http
```

Lưu ý là đối với wrapper cho `post` thì ta không thêm body.
