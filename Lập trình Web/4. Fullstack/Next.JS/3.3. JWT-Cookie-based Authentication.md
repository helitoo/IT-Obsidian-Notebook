
```insta-toc
---
title:
  name: Mục lục
  level: 1
  center: false
exclude: ""
style:
  listType: number
omit: []
levels:
  min: 1
  max: 6
---

# Mục lục

1. Xây dựng API gửi về token
    1. JWT - JSON Web Token
    2. Token
2. Bắt đầu phiên đăng nhập
    1. Xây dựng API
    2. Sử dụng
3. Bảo vệ các private routes
    1. Bảo vệ thủ công
    2. Middleware
4. Quản lý mật khẩu
```

# Xây dựng API gửi về token

## JWT - JSON Web Token

Token được xây dựng dựa trên **JWT**. JWT là một dạng chuẩn của token có độ bảo mật cao
![](https://fusionauth.io/img/shared/json-web-token.png)
Đọc thêm về JWT [tại đây](https://viblo.asia/p/tim-hieu-ve-json-web-token-jwt-7rVRqp73v4bP).

Để sử dụng JWT, bạn cần phải tải package này:
```sh
npm install jsonwebtoken
npm install --save-dev @types/jsonwebtoken
```

Gói `@types/jsonwebtoken` là định nghĩa TS của jwt.

## Token

Token là một loại dữ liệu đặc biệt dùng để xác minh danh tính của user.
Token sẽ được đính vào **header** của mỗi request client gửi cho server thông qua trường `credentials`. Thường thi `credentials="include"`.

Có 2 loại:
1. **Access token**: Token ngắn hạn, dùng để xác thực mỗi lần user truy cập tài nguyên.
2. **Refresh token**: Token dài hạn, dùng để cấp access token.

>[!question] Tại sao cần phân chia thành token ngắn hạn và dài hạn?
>- Nếu token có hạn sử dụng quá dài thì nguy cơ bị hack càng cao.
>- Nếu token có hạn sử dụng quá ngắn thì giảm UX, vì client buộc phải đăng nhập nhiều lần mỗi khi token hết hạn.
>=> Cần kết hợp token dài và ngắn.

# Bắt đầu phiên đăng nhập

## Xây dựng API

`app/api/auth/login/route.ts`
```ts
import { NextResponse } from "next/server";
import jwt from "jsonwebtoken";

export async function POST(req: Request) {
  const { email, password } = await req.json();

  if (false)
    return NextResponse.json({ error: "Sai thông tin" }, { status: 401 });

  // Tạo JWT tokens

  const accessToken = jwt.sign({ email }, process.env.JWT_SECRET!, {
    expiresIn: "15m",
  });

  const refreshToken = jwt.sign({ email }, process.env.REFRESH_SECRET!, {
    expiresIn: "90d",
  });

  const res = NextResponse.json({ success: true });

  // Lưu token vào cookie để tiện sử dụng

  res.cookies.set("access_token", accessToken, {
    httpOnly: true,
    secure: true,
    sameSite: "strict",
    path: "/",
    maxAge: 15 * 60, // 15'
  });

  res.cookies.set("refresh_token", refreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: "strict",
    path: "/",
    maxAge: 90 * 24 * 60 * 60, // 90 ngày
  });

  return res;
}
```

>[!note]
>Trên thực tế, hạn sử dụng của token và hạn sử dụng của cookie không liên quan gì nhau. Nhưng nó thường giống nhau để dễ kiểm soát luồng logic.

`.env.local`
```env
JWT_SECRET=1e93adffa201acdd70829bcb0ea2f23913c6a88ce1008dd3c629d7ff2089c128da4ae0e4de14c36a60c0e93498301d5f52f6c983174949df68b049d62133bc47
REFRESH_SECRET=1f450844d0890995f542e280c23cd885182d9a6d35b498b4b6660dc97076b46e80ef7d543ecfe00da27c8fe898b44956118e37f4acb1260a6494c741bc42f206
```

Secret là một mã riêng tư dùng để giải mã JWT, càng phức tạp càng tốt. Bạn có thể sinh mã này ngẫu nhiên qua lệnh:
```sh
node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"
```

## Sử dụng

**Các dùng đơn thuần**:

```ts
const login = async () => {
    const res = await fetch("/api/login", {
      method: "POST",
      body: JSON.stringify({ email, password }),
      headers: { "Content-Type": "application/json" },
    });
    setMsg(res.ok ? "Thành công!" : "Thất bại!");
  };
```

**Dùng wrapper như sau**:


# Bảo vệ các private routes

Trong ví dụ trước, ta đã lưu các token tại cookie `access_token` và `refresh_token`. Khi có request, ta lấy ra để kiểm tra là được.

## Bảo vệ thủ công

`app/lib/auth.ts`
```tsx
import { cookies } from "next/headers";
import jwt from "jsonwebtoken";

export async function checkAuth(): Promise<boolean> {
  const cookieStore = await cookies();
  const access = cookieStore.get("access_token")?.value;
  const refresh = cookieStore.get("refresh_token")?.value;

  if (!access) return false;

  try {
    // TH1: Access token hợp lệ

    jwt.verify(access, process.env.JWT_SECRET!);
    return true;
  } catch (err) {
    // TH2: Token hết hạn -> Thử lấy refresh, nếu refresh hợp lệ thì cấp access mới
    if (!refresh) return false;

    try {
      const payload = jwt.verify(refresh, process.env.REFRESH_SECRET!) as any;

      const newAccess = jwt.sign(
        { email: payload.email },
        process.env.JWT_SECRET!,
        { expiresIn: "1m" }
      );

      cookieStore.set("access_token", newAccess, {
        httpOnly: true,
        secure: true,
        sameSite: "strict",
        path: "/",
        maxAge: 60,
      });

      return true;
    } catch {
      return false;
    }
  }
}
```

Đối với client, client không được phép truy cập các cookie có `httpOnly` nên client phải gọi hàm trên qua API:

`app/api/auth/me/route.ts`
```ts
import { NextResponse } from "next/server";
import { checkAuth } from "@/app/lib/auth";

export async function GET() {
  const ok = await checkAuth();
  return NextResponse.json({ isAuth: ok });
}
```
Client:
```ts
const [isAuth, setIsAuth] = useState<boolean | null>(null);

useEffect(() => {
  fetch("/api/auth/me", { credentials: "include" })
    .then(res => res.json())
    .then(data => setIsAuth(data.isAuth))
    .catch(() => setIsAuth(false));
}, []);
```

## Middleware

`app/middleware.ts`
```ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import jwt from "jsonwebtoken";

export async function middleware(req: NextRequest) {
  const access = req.cookies.get("access_token")?.value;
  const url = req.nextUrl;

  if (!access)
    return NextResponse.redirect(new URL("/", url));

  try {
    // TH1: Access token hợp lệ
    
    jwt.verify(access, process.env.JWT_SECRET!);
    return NextResponse.next();
    
  } catch (err) {
    // TH2: Token hết hạn -> Thử lấy refresh, nếu refresh hợp lệ thì cấp access mới
    
    const refresh = req.cookies.get("refresh_token")?.value;
    if (!refresh)
      return NextResponse.redirect(new URL("/", url));

    try {
      const payload = jwt.verify(refresh, process.env.REFRESH_SECRET!) as any;
      
      const newAccess = jwt.sign(
        { email: payload.email },
        process.env.JWT_SECRET!,
        { expiresIn: "1m" }
      );

      const res = NextResponse.next();
      
      res.cookies.set("access_token", newAccess, {
        httpOnly: true,
        secure: true,
        sameSite: "strict",
        path: "/",
        maxAge: 60,
      });
      
      return res;
      
    } catch {
      return NextResponse.redirect(new URL("/", url));
    }
  }
}

export const config = {
  matcher: ["/private/:path*"], // Các route thuộc /privates/ đều được bảo vệ
};
```

# Quản lý mật khẩu

Mật khẩu không thể lưu trữ thẳng vào database, càng không thể gửi về client.

```sh
npm install bcryptjs
```







