
# Giao thức TCP / UDP

Tầng vận chuyển có 2 giao thức chính là TCP và UDP.

|                     | TCP<br>(Transmission control protocol)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | UDP<br>(User datagram protocol)                                                                                |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| **Nền tảng**        | [[4.2. Chuyển tiếp (Fowarding)#Mạch ảo và Mạch gói tin\|Mạch ảo (Hướng kết nối)]].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | [[4.2. Chuyển tiếp (Fowarding)#Mạch ảo và Mạch gói tin\|Mạch gói tin (Phi kết nối)]] (các gói tin được đối xử độc lập).    |
| **Cấu trúc header** | **Các trường**:<br>- `Source port`.<br>- `Dest port`.<br>- `Sequence number`: Số thứ tự của byte đầu tiên của segment. `Seq` đầu tiên do OS khởi tạo bằng *thuật toán*.<br>- `ACK number`: `Seq` của segment tiếp theo.<br>- `Recieve window`: Số lượng byte mà bên nhận có thể nhận thêm.<br>- `Checksum`.<br>- `Urgent pointer`.<br>- `TCP options`.<br><br>**Các cờ**:<br>- `ACK`: Đánh dấu đây là segment chứa `ACK number`.<br>- `SYN`: Đánh dấu đây là segment đề nghị *mở kết nối*.<br>- `FIN`: Đánh dấu đây là segment đề nghị *đóng kết nối*.<br>- `URG`, `PSH`, `RST`.<br><br>=> Server có thể thực hiện nhiều TCP connection vì mỗi connection đều định danh được nguồn và đích. | **Các trường**:<br>- `Source port`.<br>- `Dest port`.<br>- `Length`: Độ dài toàn segment.<br>- `Checksum`.<br> |
| **Đặc điểm**        | - **Point-to-Point**: 1 bên gửi - 1 bên nhận.<br>- Truyền tin cậy.<br>- **Full duplex**: 1 host có thể vừa nhận vừa gửi cùng lúc (*luồng 2 chiều*).<br>- **Handshaking**: 2 host kết nối trước khi truyền.<br>- **Flow control**: Giảm tốc độ khi tắc nghẽn.                                                                                                                                                                                                                                                                                                                                                                                                                                | - Ngược lại với TCP.<br><br>- Thiết lập đơn giản, nhỏ gọn.<br><br>- Tốc độ cao.                                |
| **Ví dụ**           | Email, Web, FTP, Remote login.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | DNS, VoIP, game online, streaming video.                                                                       |

>[!important]
>UDP **best effort** - nỗ lực truyền tin nhưng không đảm bảo chính xác.
>Tuy vậy, UDP **vẫn có bước kiểm tra lỗi khi truyền gói tin**.

>[!important]
>- **TCP/UDP** *không* đảm bảo **thông lượng / băng thông, độ trễ**.
>- Để giải quyết vấn đề bảo mật, thường thông qua **TLS (Transport layer security)** ở **tầng ứng dụng** để *mã hóa dữ liệu trước khi gửi*.

>[!important]
>- Cả TCP/UDP đều dùng **địa chỉ IP để định tuyến**.
>- Nhưng trên header thì chỉ dùng **số port** để mở kết nối.

>[!note] Khi nào dùng TCP, khi nào dùng UDP?
>- Các ứng dụng yêu cầu **độ chính xác** -> **TCP**.
>- Các ứng dụng yêu cầu **tốc độ, băng thông, độ trễ**,... -> **UDP**.

Một số protocol tầng Ứng dụng dựa trên TCP/UDP:

| Protocol                                          | Tầng | Dựa trên                | Port      | Chức năng                                                         | Đặc điểm                                                                                                                     |
| ------------------------------------------------- | ---- | ----------------------- | --------- | ----------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| **HTTP**<br>*Hypertext transfer protocol*         | App. | TCP<br><br>UDP (HTTP/3) | 80        | Lấy dữ liệu về từ server.                                         | - Có 2 dạng là bền vững và không bền vững.<br><br>- Msg *có thể* ở dạng **ASCII 8-bit** (`\n`, `\r`,...).                    |
| **SMTP**<br>*Simple Mail Transfer Protocol*       | App. | TCP                     | 25        | Gửi mail vào mailbox của người nhận.                              | - Bền vững.<br><br>- Msg phải ở dạng **ASCII 7-bit** (`CRLF.CRLF`,...).                                                      |
| **POP**<br>*Post Office Protocol*                 | App. | TCP                     | 110       | Tải mail về client rồi xóa mail đó ở mailbox.                     | --                                                                                                                           |
| **IMAP**<br>*Internet Mail Access Protocol*       | App. | TCP                     | 143       | Cũng như POP, nhưng mail vẫn còn ở mailbox chứ không tự động xóa. | --                                                                                                                           |
| **DNS**<br>*Domain name system*                   | App. | TCP,<br>UDP             | 53        | Gửi query để tra cứu IP và response để trả về IP.                 | --                                                                                                                           |
| **DHCP**<br>*Dynamic Host Configuration Protocol* | App. | UDP                     | 67,<br>68 | Cấp phát mạng IP.                                                 | Gồm 4 bước **DORA**:<br>- *Host*: Gửi Discovery.<br>- *Server*: Gửi Offer.<br>- *Host*: Gửi Request.<br>- *Server*: Gửi ACK. |
| **NAT**<br>*Network Address Translation*          | Net. | TCP/IP                  | --        | Chuyển dịch địa chỉ giữa mạng LAN và WAN.                         | --                                                                                                                           |
| **ICMP**<br>*Internet Control Message Protocol*   | Net. | TCP/IP                  | --        | Báo lỗi mạng, chẩn đoán mạng.                                     | `ping`: Kiểm tra tín hiệu đường truyền.<br><br>`traceroute`: Kiểm tra lộ trình gói tin.                                      |
| **ARP**<br>*Address Resolution Protocol*          | Net. | TCP/IP                  | --        | Phân giải địa chỉ IP thành MAC.                                   | Gói tin được chuyển tiếp **bảng ARP** hoặc gửi đến **broadcast**.                                                            |

# Truyền dữ liệu đáng tin cậy

>[!important]
>Nguyên lý cơ bản của RDT là **Truyền lại khi phát hiện gói tin bị lỗi, bị mất thứ tự, mất gói tin**.
>ACK/NACK, checksum chỉ là các công cụ *kiểm tra* phục vụ RDT, không phải nguyên lý của RDT.

## Checksum

**Quy trình**:
- Bên gửi:
	- Chia dữ liệu thành các chuỗi 16 bit. Nếu không đủ 16 bit thì bù bit `0` vào trước chuỗi.
	- Tính **tổng bù 1 (1’s complement sum)** trên từng chuỗi.
	- Đưa vào header.

- Bên nhận:
	- Cộng tất cả (bao gồm checksum).
	- Nếu kết quả giống trường `checksum` của header, gói tin *có khả năng có lỗi*; ngược lại thì *chắc chắn có lỗi.*

>[!important]
>- Checksum **không thể sửa lỗi**.
>- Trong các trường hợp như **dữ liệu bị đảo**, checksum không kiểm tra được lỗi (*vì `A + B` = `B + A`*).

VD:

Gói tin:
- Source Port: `0x1F90` (8080)
- Dest Port: `0x0045` (69)
- Length: `0x001C` (28 byte)
- Data: `0x54657374`.

Cộng dồn các giá trị
```
0x1F90 + 0x0045 + 0x001C + 0x54657374 = 0x546593DD
```

Lấy bù 1 (đảo bit):
```
0xAB9A6C22
```

Vậy, checksum là `0xAB9A6C22`.

Khi nhận, bên nhận cũng tính checksum và nếu cũng ra `0xAB9A6C22` thì dữ liệu được cho là không có lỗi.

## Các chiến lược xây dựng kênh truyền tin đáng tin cậy (RDT)

### Các chiến lược dựa trên nguyên lý stop-and-wait

**Stop-and-wait** là sau khi bên gửi gửi 1 gói tin:
- Router sẽ đợi cho đến khi bên nhận gửi lời xác nhận segment (có lỗi hay không).
- Sau đó bên gửi mới tiếp tục gửi segment khác.

Các cơ chế dùng trong stop-and-wait:

| Phiên bản   | Vấn đề được khắc phục         | Phương pháp                                                                                                 |
| ----------- | ----------------------------- | ----------------------------------------------------------------------------------------------------------- |
| **RDT 1.0** |                               |                                                                                                             |
| **RDT 2.0** | Giải quyết **gói hỏng**.      | Dùng **ACK/NACK và checksum**:<br>- Trả về ACK khi gói đúng.<br>- Trả về NACK khi gói sai, đợi gửi lại gói. |
| **RDT 2.1** | Giải quyết **ACK/NACK hỏng**. | **Đánh số thứ tự** cho gói: ACK/NACK hỏng là ACK/NACK có số thứ tự *bị trùng*.                              |
| **RDT 2.2** | Giải quyết **NACK hỏng**.     | **Chỉ dùng ACK**: ACK lỗi là ACK *bị trùng*.                                                                |
| **RDT 3.0** | Giải quyết **mất gói**.       | **Dùng timer**: Nếu đợi lâu quá mà bên gửi không thấy ACK thì tự động gửi lại.                              |

### Các chiến lược dựa trên nguyên lý pipelining

**Pipeling** cho phép bên gửi gửi hàng loạt gói tin thay vì gửi từng gói một như *stop-and-wait*.

Chúng ta sẽ tìm hiểu 3 thuật toán: *Go-back-end (GBN), Selective repeat (SR) và thuật toán của TCP*.

3 thuật toán trên có điểm chung:
1. Bên gửi **gửi liên tiếp một số lượng gói** cố định theo kích thước **cửa sổ trượt (Send window)** mà không cần chờ ACK cho mỗi gói.
2. Trong trường hợp thông thường, mỗi gói gửi đi sẽ nhận về 1 gói ACK tương ứng.
3. Mỗi một ACK được xác nhận, cửa sổ trượt dịch 1 đơn vị.
4. Thao tác *gửi lại gói* được thực thi khi **timeout**. Đôi khi, gói được gửi đi trước timeout, gọi là **Early timeout**.

Riêng với TCP, gói được gửi lại khi:
1. Timeout, early timeout.
2. **Truyền lại nhanh**: Khi nhận được 3 gói ACK giống nhau (**Duplicated ACK**).

Minh họa cơ chế xử lý mất gói và mất gói ACK của từng thuật toán:

|         | Go-back-end (GBN)         | Selective repeat (SR)    | RDT của TCP                                                       |
| ------- | ------------------------- | ------------------------ | ----------------------------------------------------------------- |
| Mất gói | ![[GBN-loss-segment.png]] | ![[SR-loss-segment.png]] | ![[TCP-loss-segment.png]]<br>Nửa đầu giống GBN, nửa sau giống SR. |
| Mất ACK | ![[GBN-loss-ACK.png]]     | ![[SR-loss-ACK.png]]     | ![[GBN-loss-ACK.png]]<br>Giống GBN.                               |

Như đã thấy, GBN và TCP có thể **tự xác nhận các ACK bị mất**. Cơ chế này được gọi là **ACK tích lũy (Cummulative ACK)**.

Hoạt ảnh mô phỏng:
- [GBN](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html).
- [SR](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html).

>[!important]
>Dù gói tin bị mất nhưng **Seq vẫn tăng bình thường**, vì gói tin đó vẫn gửi được.

# Các chiến lược vận chuyển gói tin của TCP

## Chiến lược RDT

**Công thức tính timeout**: Tính theo thứ tự sau:

$$
\begin{align}
&\text{RTT}_\text{sample}=t_\text{nhận ACK}-t_\text{gửi}\tag{1}\\
&\text{RTT}_\text{dev}=(1-\beta)\times\text{RTT}_\text{dev}+\beta\times|\text{RTT}_\text{sample}-\text{RTT}_\text{estimated}|;\quad\beta=0.25\tag{2}\\
&\text{RTT}_\text{estimated}=(1-\alpha)\times\text{RTT}_\text{estimated}+\alpha\times\text{RTT}_\text{sample};\quad\alpha=0.125\tag{3}\\
&\text{TimeoutInterval}=4\times\text{RTT}_\text{dev}+\text{RTT}_\text{estimated}\tag{4}
\end{align}
$$
Trong đó:
- **Sample RTT**: Là RTT thực, khác nhau ở mỗi lần đo.
- **Deviation of RTT (Safety margin)**: Là biên độ dao động của Sample RTT.
- **Estimated RTT**: Là giá trị trung bình của RTT.
- Nếu thời gian đợi ACK vượt quá đại lượng **TimeoutInterval** thì tính là timeout.

**Công thức tính giá trị trường `Seq` và `ACK`**:
$$
\begin{align}
\text{Seq}_i&=\text{Seq}_{i-1}+L_{i-1}\\
\text{ACK}_i&=\text{Seq}_{i+1}=\text{Seg}_i+L_i
\end{align}
$$

>[!caution]
>Cần phải hiểu **`ACK` là `Seq` tiếp theo mà host này muốn nhận**.

## Chiến lược điều khiển luồng (flow-control)

Điều khiển luồng là điều khiển số byte mà host nhận được. Phù hợp khi tốc độ xử lý của host không tương thích với tốc độ xử lý của transport layer.

Các bước điều khiển luồng:
1. Khi thấy dữ liệu đến, bên nhận lưu tạm nó vào buffer.
2. Bên nhận thông báo dung lượng còn trống cho buffer thông qua trường **Recieve window** (số byte mà bên nhận có thể nhận được).
3. Buffer sẽ gửi một lượng dữ liệu tối đa bằng recieve window cho server.

>[!important]
>Recieve window chính là cửa sổ trượt trong nguyên lý RDT bằng pipelining.

## Chiến lược quản lý kết nối

| Mở kết nối - 3-ways handshake                                                                                               | Đóng kết nối - 4-ways handshake                                                                                                                                                                                        |
| --------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Chỉ có client** mới có thể yêu cầu mở kết nối.                                                                            | **Cả client hoặc server** đều có thể yêu cầu đóng kết nối.                                                                                                                                                             |
| Dùng **cờ SYN**.                                                                                                            | Dùng **cờ FIN - Finish**.                                                                                                                                                                                              |
| - **Bên gửi**: Muốn mở kết nối, gửi SYN segment.<br>- **Bên nhận**: Trả lại SYN/ACK segment.<br>- **Bên gửi**: Gửi lại ACK. | - **Bên gửi**: Muốn đóng kết nối, gửi FIN segment.<br>- **Bên nhận**: Trả lại ACK và gửi nốt các segment chưa được gửi. Sau đó mới gửi lại FIN segment lần 2 là xác nhận đóng kết nối.<br>- **Bên nhận**: Gửi lại ACK. |
| ![[3-ways-handshake.png]]                                                                                                   | ![[4-ways-handshake.png]]                                                                                                                                                                                              |

>[!note]
>Căn cứ vào cờ **flag** của segment mà biết đó là segment gì.

>[!note]
>Nguyên lý là:
>- Mở kết nối - 3-ways-handshake: **Dùng SYN**.
>- Đóng kê nối - 4-ways-handshake: **Dùng FIN**.
>
>Để đảm bảo RDT, mỗi lần nhận segment thì phải trả về ACK để kết thúc.

## Chiến lược điều khiển tắc nghẽn - AIMD

**Cơ chế AIMD**:
- Liên tục tăng tốc độ gửi gói theo **cấp số nhân**.
- Nếu mất gói (*timeout / 3 ACK liên tiếp*) thì giảm tốc độ theo **cấp số cộng**.

Gọi:
- **cwnd (Congestion window)**:
	- Tổng kích thước lớn nhất được phép gửi các gói tin (*Số gói tin được gửi cùng lúc*).
	- Đơn vị là **MSS (Maxium segment size, kích thước gói tin tối đa)**.
	- Tốc độ gửi tỷ lệ thuận với cwnd.

- **ssthread (Slow start threshold)**:
	- Ngưỡng kết thúc giai đoạn *slowstart* và chuyển sang *congestion avoidance*.
	- Thường là khá lớn.
	- **Được thay đổi khi *mất gói / timeout***.

**Các giai đoạn điều khiển tắc nghẽn**:

| Giai đoạn                        | Điều kiện kích hoạt | Ở mỗi RTT                                                                                                                                                                                                                 | Hình dáng đồ thị                                               |
| -------------------------------- | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| (Khởi tạo)                       |                     | cwnd = 1 MSS                                                                                                                                                                                                              | --                                                             |
| **Slow start**                   |                     | $$\boxed{\text{cwnd}_i=\text{cwnd}_{i-1}\times2}$$                                                                                                                                                                        | Cong lên.                                                      |
| **Congestion avoidance**         | cwnd ≥ ssthread     | $$\boxed{\text{cwnd}_i=\text{cwnd}_{i-1}+1}$$                                                                                                                                                                             | Thẳng dốc lên.                                                 |
| **Fast recovery**<br>(TCP Reno)  | Mất gói             | **Khi nhận được 3 ACK trùng**:<br>$$\boxed{\text{cwnd}_i=\frac{\text{cwnd}_{i-1}}{2}+3}$$Sau đó quay về *Congestion avoidance*.<br><br>---<br>**Khi timeout**:<br>$$\boxed{\text{cwnd}_i=1}$$Sau đó quay về *Slow start*. | 3 ACK trùng: Thẳng thoải lên.<br><br>Timeout: Giảm thẳng về 1. |
| **Fast recovery**<br>(TCP Tahoe) | Mất gói             | $$\boxed{\text{cwnd}_i=1}$$Sau đó quay về *Slow start*.                                                                                                                                                                   | Giảm thẳng về 1.                                               |

`ssthread` không thể tăng mà **giảm mỗi lần phát hiện mất gói**.

Sơ đồ minh họa sự khác nhau giữa Reno và Tahoe:
![](tcp-congestion.png)

