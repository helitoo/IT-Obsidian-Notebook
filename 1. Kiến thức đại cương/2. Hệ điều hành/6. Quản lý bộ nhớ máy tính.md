
# Các khái niệm cơ sở

## Quản lý bộ nhớ

**Quản lý bộ nhớ** là công việc của OS với sự hỗ trợ của phần cứng nhằm **phân phối, sắp xếp** các process trong bộ nhớ sao cho hiệu quả.

## Mục tiêu

Nạp càng nhiều process vào bộ nhớ càng tốt (**tăng mức độ đa chương**).

Ở hầu hết hệ thống, **kernel sẽ chiếm một phần cố định của bộ nhớ**; phần còn lại phân phối cho các process.

## Yêu cầu đối với việc quản lý bộ nhớ

- **Cấp phát** bộ nhớ cho các process.
- **Tái định vị** (Relocation) khi swapping (*chuyền bộ nhớ qua nhiều process truy cập*).
- **Bảo vệ** bộ nhớ khỏi các truy cập bất hợp pháp.
- **Chia sẻ** bộ nhớ cho các process dùng chung.
- **Kết nối** địa chỉ luận lý của user vào địa chỉ thực.

# Các kiểu địa chỉ nhớ

## Các kiểu địa chỉ nhớ

| Địa chỉ vật lý                                                                                                           | Địa chỉ luận lý                                                                                                                               |
| ------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |
| **Địa chỉ vật lý, Địa chỉ thực (Physical address)**<br><br>Là *vị trí thực* trong bộ nhớ chính.                          | **Địa chỉ luận lý, Địa chỉ ảo (Loical address, Virtual address)**<br><br>Là vị trí *diễn tả bên trong 1 chương trình*.                        |
| **Địa chỉ tuyệt đối (Absolute address)**<br><br>Là một phần của địa chỉ vật lý, được *gắn cố định cho mỗi chương trình*. | **Địa chỉ tương đối (Relative address)**<br><br>Là một loại địa chỉ luân lý, dùng để *re-allocation*, *dùng địa chỉ chương trình làm mốc đo*. |

**Biểu diễn địa chỉ nhớ**:
- Trong *source code*: **Symbolic** (các biến, hằng, pointer,...).
- Trong *compile time*: Thường là **địa chỉ khả tái định vị (tương đối)**.

Lập trình viên **không cần biết địa chỉ vật lý** vì đã có địa chỉ luận lý.

## Chuyển đổi địa chỉ (Kết buộc địa chỉ, Address binding)

**Chuyển đổi địa chỉ**: Là quá trình ánh xạ một địa chỉ từ không gian địa chỉ này sang không gian địa chỉ khác.

**Địa chỉ lệnh và dữ liệu được chuyển đổi thành địa chỉ thực** xảy ra tại 3 thời điểm:
1. **Compile time**: Nếu biết trước địa chỉ bộ nhớ của chương trình thì có thể kết gán địa chỉ tuyệt đối lúc biên dịch. Phải **biên dịch lại** nếu thay đổi địa chỉ nạp chương trình.
2. **Load time**: Loader phải chuyển đổi **địa chỉ khả tái định vị thành địa chỉ thực** dựa trên một địa chỉ nền.
3. **Nạp chương trình**: Tính toán địa chỉ thực, phải **nạp lại (reload)** nếu địa chỉ nền thay đổi.

## Dynamic linking & Dynamic loading

|                      | Dynamic linking<br>(Liên kết động)                                                                                                                                                                                                                                                                                                                                                              | Dynamic loading<br>(Nạp động)                                                                                                                                                                                                                                                 |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Khái niệm**        | Là kỹ thuật mà **việc liên kết với các thư viện ngoài (External module)** (`.dll` - Windows / `.so` - Linux).                                                                                                                                                                                                                                                                                   | Là kỹ thuật mà một đoạn mã (*module / routine*) **chỉ được nạp vào bộ nhớ khi cần**, không cần nạp toàn chương trình ngay từ đầu.                                                                                                                                             |
| **Cơ chế**           | Mỗi module chứa các **stub**. Stub là một đoạn mã nhỏ tham chiếu (*reffer*) đến **routine** (đoạn mã) của các external module.<br><br>- **Khi stub được gọi lần đầu**:<br>1. Nạp routine vào bộ nhớ.<br>2. Tự thay thế chính nó bằng địa chỉ của routine.<br>3. Thực thi routine.<br><br><br>- **Khi stub được gọi các lần sau**: Routine được thực thi trực tiếp chứ không cần thông qua stub. | OS **cung cấp các thủ tục, thư viện** để dev thiết kế dynamic loading.                                                                                                                                                                                                        |
| **Thời điểm xảy ra** | Runtime.                                                                                                                                                                                                                                                                                                                                                                                        | Runtime.                                                                                                                                                                                                                                                                      |
| **Ưu điểm**          | Không cần biên dịch toàn bộ chương trình một lúc  -> Giảm kích thước -> Tăng độ hiệu dụng bộ nhớ.                                                                                                                                                                                                                                                                                               | Không cần biên dịch toàn bộ chương trình một lúc  -> Giảm kích thước -> Tăng độ hiệu dụng bộ nhớ.<br><br>Đặc biệt hiệu quả trong trường hợp tồn tại khối lượng lớn mã chương trình có tần suất sử dụng thấp, không được sử dụng thường xuyên (*ví dụ các thủ tục xử lý lỗi*). |

Cả dynamic linking và dynamic loading đều xảy ra ở **runtime**.

# Mô hình quản lý bộ nhớ

Trong chương này, mô hình quản lý bộ nhớ là một mô hình đơn giản, *không có bộ nhớ ảo*. Một process phải được nạp hoàn toàn vào bộ nhớ thì mới được thực thi.

Có 4 cơ chế:
1. Phân chia cố định (Fixed partitioning).
2. Phân chia động (Dynamic partitioning).
3. Phân trang đơn giản (simple paging).
4. Phân đoạn đơn giản (simple segmentation).

## Phân mảnh (Fragmentation)

**Phân mảnh** là hiện tượng **bộ nhớ bị chia cắt thành nhiều phần nhỏ**, khiến việc sử dụng bộ nhớ *không hiệu quả*.

**Phân mảnh ngoại (External fragmentation)**
- Vùng nhớ bị ==rời rạc==, không thể cấp cho process dù kích thước các vùng rời rạc ấy vẫn đủ cho process.
- Khắc phục: Cơ chế Kết khối (*Compaction*) để gom lại thành vùng nhớ liên tục.

**Phân mảnh nội (Internal fragmentation)**:
- Vùng nhớ được cấp cho process ==lớn hơn== so với process cần, nên bị thừa một phần không gian.
- Thường xảy ra khi bộ nhớ thực được chia thành các khối kích thước cố định (*Fixed-sized block*) và các process được cấp phát theo đơn vị khối (phân trang - paging).

>[!note]
>- **Phân chia động** ==dễ bị== **phân mảnh ngoại** do kích thước *mỗi partition biến thiên liên tục*, gây ra các khoảng trống rời rạc.
>- **Phân chia cố định / Phân trang** ==không thể== **phân mảnh ngoại** do các partition / trang đều *có cùng kích thước*.
>- **Phân chia cố định** ==dễ bị== **phân mảnh nội** do kích thước *các partition thường lớn* hơn process. Các process thường yêu cầu kích thước nhỏ.
>- **Phân trang** ==vẫn có thể== bị **phân mảnh nội** nếu *bị thừa các trang cuối chưa được cấp phát*.

## Phân chia (Partitioning)

**Phân chia**: Là chia bộ nhớ chính thành nhiều phần (*Partition*), dùng cho cấp phát *liên tục*.

1. **Phân chia cố định (Fixed partitioning)**:
	- Các partition có kích thước cố định, bằng nhau hoặc khác nhau -> Dễ bị **phân mảnh nội**.
	- Khi process được xét để cấp bộ nhớ:
		- Process có kích thước $\leq$ partition -> Nạp process vào.
		- Process có kích thước $>$ partition -> Dùng *Overlay*.
		- Process được nạp nhưng vùng nhớ đang bận -> Đưa process đó sang bộ nhớ phụ (*queue*) để đợi. Có thể có 1 queue hoặc nhiều queue.

2. **Phân chia động (Dynamic partitioning)**:
	- Các partition có thể có kích thước khác nhau, mỗi process được cấp chính xác 1 vùng nhớ cần thiết -> Dễ bị **phân mảnh ngoại**.
	- **Placement**: Là kỹ thuật quyết định *cấp phát khối bộ nhớ nào cho process*, sao cho giảm Compaction nhất có thể. Có 4 loại:
		1. **Best-fit**: Chọn khối trống **NHỎ NHẤT** có thể.
		2. **Worst-fit**: Chọn khối trống **LỚN NHẤT** có thể.
		3. **First-fit**: Chọn khối trống **ĐẦU TIÊN** có thể cấp phát.
		4. **Next-fit**: Chọn khối trống **ĐẦU TIÊN** có thể cấp phát **tính từ vị trí khối được cấp phát cuối cùng**.

>[!note] Chú ý phân biệt với các kỹ thuật page-fault service routine (PFSR) (Demand paging) của virtual memory
>- **FIFO (First-in First-out)**: Thay thế trang **đã được dùng** sớm nhất.
>- **LRU (Least Recently Used)**: Thay thế trang **hiện chưa dùng** lâu nhất.
>- **OPT (Optimal)**: Thay thế trang **dự định** sẽ dùng lâu nhất hoặc không dùng nữa.

## Phân trang (Paging)

![](paging.png)

**Phân trang (Paging)**: Là chia bộ nhớ chính thành nhiều phần, dùng cho cấp phát **không liên tục**.
- **Trong bộ nhớ vật lý**: Chia thành các **frame**, mỗi frame rộng $2^n$ byte.
- **Trong bộ nhớ luận lý**: Chia thành các **page**, có kích thước như frame.

#### Page table

Một process cần $N$ page thì sẽ cần được cấp $N$ frame tương ứng. Page và frame được ánh xạ thông qua **Bảng phân trang (Page table)**.
-> Dễ *phân mảnh nội*.
-> Các trang **KHÔNG** cần phải liên tục.

Mỗi process được OS cấp một page table, gồm 2 thanh ghi (*Thanh ghi kết hợp* - Associative / *Translation look-aside buffers* - TLBs):
- **Page-table base register (PTBR)**: Địa chỉ page table.
- **Page-table length register (PTLR)**: Kích thước của page table, có thể dùng cho cơ chế *bảo vệ bộ nhớ*.
Các TLB có nhiệm vụ **tăng tốc độ mapping địa chỉ ảo và địa chỉ thực** nhờ vào việc *catch các entry của page table*.

Như vậy, cứ mỗi một thao tác truy cập lệnh / dữ liệu thì cần **2 lần truy cập bộ nhớ chính**:
- Lần 1 cho page table.
- Lần 2 cho lệnh / dữ liệu.

>[!note]
>- Mỗi process có thể được cấp 1 hay vài *page table*.
>- Process con được thừa hưởng page table của process cha.

#### Xây dựng page table

**Các đại lượng**:

|                                                                |                                                      |
| -------------------------------------------------------------- | ---------------------------------------------------- |
| ==$o$ (Bits)==: Độ dời trang (Page offset).                    | ==$2^o$ (Bytes)==: Kích thước mỗi frame / page.      |
| ==$n$ (Bits)==: Số lượng page = số lượng entry của page table. | ==$2^n$ (Bytes)==: Kích thước không gian địa chỉ ảo. |

Mỗi địa chỉ ảo đều có 2 phần:
- **Chỉ số trang (Page number)**: Được đánh số từ $0$ đến $n-1$. Số lượng bit cần dùng là $2^{\lceil m\rceil}=n$.
- **Độ dời trang (Page offset)**: Là $o$ bit phải cùng của địa chỉ.
Vậy **độ dài địa chỉ** là $m+o$ bits.

**Kích thước mỗi entry của page table**:
- Page number: $o$ (nếu $2^{\lceil o\rceil}$ là kích thước mỗi page).
- Frame number: $p$ (nếu $2^{\lceil p\rceil}$ là kích thước mỗi frame).
- Valid / Invalid bit: $1$ (nếu đề yêu cầu).
Vậy kích thước mỗi entry: $o+p+1$ bits.

**Cách khác để tính số lượng entry**: $\lceil\dfrac{\text{totalSize}}{\text{entrySize}}\rceil$.

#### Effective access time (EAT) - Thời gian truy xuất hiệu dụng

Gọi:
- $t_{lookup}$: Thời gian tìm số trang trong Page table (TLBs) (Associate lookup).
- $t_{access}$: Thời gian chu kỳ truy xuất bộ nhớ.
- $h$: Tỷ lệ số lần tìm thấy chỉ số trang (hit).

Khi đó:
$$
\boxed{\text{EAT}=(t_{lookup}+t_{access})h+(t_{lookup}+2.t_{access})(1-h)}
$$
Trong đó:
- $t_{lookup}+t_{access}$: Thời gian khi **tìm thấy page number** trong page table.
- $t_{TLB}+2t_{access}$: Thời gian khi không tìm thấy page number, phải truy cập page table **lấy page number** (1 lần) rồi **truy cập lại bộ nhớ lấy frame number** (1 lần nữa).

# Bảo vệ bộ nhớ

Trong *page table*, có 2 loại bit để phục vụ cho bảo vệ bộ nhớ:
- **Bit bảo vệ (Protection bits)**: Gồm 3 trạng thái là *Read-only, Read-Write, Execute-only*.
- **Bit hợp lệ (Valid/Invalid bits)**: Cho biết tính hợp lệ của page (nếu page đang thuộc process).

# Hoán vị (Swapping)

Khi **bộ nhớ của 1 process** bị block, bộ nhớ của nó tạm thời bị swap ra khỏi bộ nhớ chính (**Swap out / Roll out**) và lưu trên một hệ thống lưu trữ phụ. Sau đó, bộ nhớ đó có thể được giải phóng (**Swap in / Roll in**) để tprocess sử dụng.

>[!caution]
>- Thuật ngữ *Swap in, Swap out* là dùng trong **Robin Round**.
>- Thuật ngữ *Roll in, Roll out* là dùng trong **Priority-based scheduling**.
