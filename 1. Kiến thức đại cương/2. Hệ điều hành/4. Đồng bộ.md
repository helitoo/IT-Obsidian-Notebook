
# Race condition

Race condition là hiện tượng xảy ra khi **nhiều process cùng truy cập vào một vùng nhớ đồng thời** (**Vùng tranh chấp - Critical section / Critical region**).

>[!note]
>**Vùng tranh chấp** là một vùng nhớ hay một đoạn mã bậc cao (thao tác lên dữ liệu) tại vùng nhớ đó.

**Hậu quả**: Dữ liệu bị sai, không nhất quán.

**Bài toán Consumer - Producer**:
- Consumer process: Liên tục tăng biến `count`.
- Producer process: Liên tục giảm biến `count`.
Lúc này, vùng tranh chấp là biến `count`.

**Bài toán writer - reader**:
- Tại 1 thời điểm, có thể có nhiều reader cùng đọc dữ liệu hoặc nhiều reader cùng đọc dữ liệu.
- Các reader nằm trong hàng đợi reader, các writer nằm trong hàng đợi writer.

**Bài toán cấp phát PID**:
- Giả sử có 2 process được gọi bởi `fork()` và sẽ được cấp PID bởi biến `next_available_pid`.
- Nếu 2 process được fork cùng lúc thì sẽ xảy ra mâu thuẫn và 1 PID có thể được cấp 2 lần.
Lúc này, vùng tranh chấp là `next_available_pid`.

# Các giải pháp đồng bộ

**Tiêu chuẩn của một lời giải tốt** gồm:
1. **Loại trừ tương hỗ (Mutual exclusion)**: Nếu process P đang thực thi tại vùng tranh chấp của nó, thì Q (và mọi process khác) phải bị chặn lại ở vùng tranh chấp của chúng, cho đến khi P thoát ra.
2. **Tiến triển (Progress)**: Một process ở ngoài vùng tranh chấp thì *không được ngăn cản các process khác* vào vùng tranh chấp.
3. **Chờ đợi giới hạn (Bounded waiting)**: Mỗi process phải *chờ để được vào vùng tranh chấp* trong một khoảng thời gian cố định -> Các process phải thực thi *tuần tự* -> Gây ra **starvation**.

>[!important] Nhầm lẫn về mutual exclusion
>- 2 process A và B có không gian địa chỉ riêng, chỉ có thể xung độ về resources chứ không xung đột về địa chỉ.
>- Vùng tranh chấp của A là 1 đoạn mã thuộc A.
>- Do đó, **A không bao giờ có thể thực thi tại vùng tranh chấp của B**, nên đây **KHÔNG là một phạm trù của bài toán đồng bộ**.

>[!important] Nhầm lẫn về bounded waiting
>- Process không cần phải từ bỏ CPU khi đã vào vùng tranh chấp để nhường lại cho các process khác.
>- Process chỉ từ bỏ CPU khi đã sử dụng xong.

>[!important] Nhầm lẫn về preemptive
> - Preemptive là vấn đề thuộc **bài toán tắc nghẽn**, không phải đồng bộ.
> - Một process có quyền trưng dụng 1 resources mà nó có độ ưu tiên cao hơn. Điều này không gây deadblock nhưng có thể gây tắc nghẽn.

**Phân loại lời giải dựa trên sự hỗ trợ từ phần mềm / phần cứng**:
1. **Dựa trên phần mềm (ngắt)**:
	- Dựa vào các thuật toán.
2. **Dựa trên phần cứng**:
	- Cần một vài phần cứng đặc biệt.
	- -> Khá *phức tạp* và *không thể truy cập* được bởi dev của các chương trình ứng dụng.

**Phân loại lời giải dựa trên sự hỗ trợ từ OS**:
1. **Busy waiting**:
	- Process liên tục kiểm tra điều kiện để thực thi chương trình.
	- Không cần OS, do dev triển khai.
2. **Sleep & Wake-up**:
	- OS cung cấp system call để *ngắt và đánh thức* process khi không thể / có thể đưa process vào vùng tranh chấp.
	- -> Gây *lãng phí tài nguyên* CPU vì liên tục kiểm tra điều kiện chờ đợi tiến vào vùng tranh chấp.

**Tóm tắt 1 số giải pháp**:

|                  | Phần mềm    | Phần cứng                     | OS                         |
| ---------------- | ----------- | ----------------------------- | -------------------------- |
| **Busy waiting** | - Peterson. | - Mutex lock.<br>- Spin lock. | --                         |
| **Sleep-Wakeup** | --          | --                            | - Semaphore.<br>- Monitor. |

**Một số lệnh dùng cho đồng bộ**:

| Phần mềm                | Phần cứng                       |
| ----------------------- | ------------------------------- |
| - `load`.<br>- `store`. | - `automic`.<br>- `TestAndSet`. |

**Một số giải pháp cụ thể**:

| Tên                                | Nguyên lý                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Nhược điểm                                                                                                                      |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **Giải pháp sơ khai 1**            | - Sử dụng 2 lệnh hợp ngữ đơn nguyên (*không thể bị cắt ngang*) là `load` và `store`.<br><br>- Duy trì một biến chung **`turn`** trỏ đến process có quyền vào vùng tranh chấp.                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Không **progess** và **bounded waiting**.                                                                                       |
| **Giải pháp sơ khai 2**            | - Cũng sử dụng `load` và `store`.<br><br>- Duy trì một biến chung **`flag`** cho phép các process bật `flag` để yêu cầu vào vùng tranh chấp.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Không **mutual exclusion**.                                                                                                     |
| **Giải pháp Peterson**             | - Là kết hợp giữa giải pháp 1 và giải pháp 2:<br>  + `flag`: Thể hiện các process *MUỐN vào* (ưu tiên 2).<br>  + `turn`: Thể hiện các process *ĐƯỢC vào* (ưu tiên 1).<br><br>- Peterson busy-waiting ở chỗ nó liên tục kiểm tra điều kiện (*strict-alternative*).<br><br>- Đối với kiến trúc máy tính hiện đại, để gia tăng hiệu năng thì CPU / compiler sẽ tự **sắp xếp lại các lệnh** `load`, `store`,... => Cần *memory barrier*.                                                                                                                                                                                                                    | Thứ tự hoạt động có thể bị sai vì đặc điểm CPU hiện đại -> Cần áp dụng *memory barrier*.<br><br>Các tính chất khác thì đảm bảo. |
| **Mutex lock**                     | Mutex lock là một ổ khóa.<br>  - Process muốn vào -> Cần `acquire()` để lấy khóa.<br>  - Process muốn ra -> Cần `release()` để trả khóa.<br><br>`acquire()` và `release()` chỉnh sửa một biến chung `available`. Nếu `available = false` thì các process khác không thể vào.                                                                                                                                                                                                                                                                                                                                                                            | Lãng phí CPU do **busy waiting** (các process phải đợi nhiều).                                                                  |
| **Spinlock**                       | Nếu process không lấy được khóa thì sẽ **xoay vòng kiểm tra liên tục** cho đến khi vào được.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Lãng phí CPU do **busy waiting** (các process phải đợi nhiều).                                                                  |
| **Semaphore**                      | Semaphore bao gồm:<br>  - **Biến `s`** thể hiện số resource còn khả dụng.<br>  - **Hàng đợi `q`** chứa các process bị block và đợi. Số lượng process của `q` là `-s`.<br><br>Biến `s` được kiểm soát bởi 2 hàm sau:<br>  - `wait(s)`: `s--` (chạy khi process *MUỐN* vào, nếu `s` $\leq0$ thì process phải chờ).<br>  - `signal(s)`: `s++` (chạy khi process *ĐÃ* ra).<br><br>- **Binary semaphore**: Khi `s` chỉ có 2 giá trị `0` và `1`.<br>- **Counting semaphore**: Là dạng tổng quát của `s`, dùng cho nhiều resource bị tranh chấp. 1 counting semaphore có thể được thực hiện bởi nhiều binary semaphore.<br><br>Mutex lock là 1 loại semaphore. |                                                                                                                                 |
| **Semaphore<br>(no busy waiting)** | Các process không được vào sẽ bị **block**.<br><br>Các process sẽ được vào sẽ được **wake-up**.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                 |
| **Monitor**                        | Monitor là một cơ chế giúp **tự động hóa việc sử dụng mutex lock / semaphore**.<br>- Sao cho *chỉ có 1 process được tạo monitor tại 1 thời điểm*.<br>- Các dev *không cần điều khiển thủ công* nữa.<br><br>Monitor gồm có:<br>  - **Các biến nội bộ**: Được khai báo bên trong monitor và chỉ được truy cập bởi các thủ tục của monitor. Trong đó, **condition variable** đảm bảo việc process có thể vào vùng tranh chấp không.<br>  - **Các thủ tục**: Được định nghĩa bởi dev.                                                                                                                                                                       |                                                                                                                                 |

**Cơ chế memory barrier**:
- Là một instruction mà bắt buộc **mọi thay đổi trong bộ nhớ phải được thông báo đến mọi CPU**.
- Nhờ vậy, các lệnh `load`, `store`,... sẽ được thực thi tuần tự thay vì chồng chéo lên nhau.
- -> Hữu hiệu cho peterson.

**Cơ chế memory model**:
- **Memory model**: Là mô hình hoạt động của bộ nhớ, bao gồm cách thức quản lý & truy xuất đến các vùng nhất.
- Có 2 loại:
	- **Mô hình bộ nhớ được sắp xếp mạnh**: Các thay đổi trên bộ nhớ sẽ *được **toàn bộ** processor biết*. Là nền tảng của *Memory barrier*.
	- **Mô hình bộ nhớ được sắp xếp yếu**: Ngược lại.

**Cơ chế condition variable**:
- Condition variable là một công cụ bổ trợ trong monitor, cho phép process **`wait(s)`** và **`signal(s)`** khi thỏa mãn một số điều kiện, trái lại, process sẽ được đưa vào hàng đợi của condition variable.
- Conditon variable chỉ có thể thao tác với `wait(s)` và `signal(s)`.
- Mỗi condition có một queue riêng chứa các process đang đợi.
- Cần dev định nghĩa từ trước.
- Condition variable là các biến toàn cục trong monitor, **không thể truy cập từ bên ngoài monitor**.

>[!important]
>- Vùng bộ nhớ định nghĩa các lệnh `wait(s)`, `signal(s)` là **vùng tranh chấp (Critical region)**. Đây là các lệnh không thể bị ngắt giữa chừng.
>- `wait`, `for`, `signal`,... là các lệnh kiểm soát resources.
>- Binary semaphore là một dạng của mutex lock.

# Liveness - Deadblock

**Liveness** là tập các đặc điểm mà hệ thống phải thỏa mãn để *các process được chạy*.

**Deadblock** là tình trạng *các process chờ nhau vĩnh viễn, không vào được vùng tranh chấp.

>[!important]
>Bất kỳ giải pháp đồng bộ nào **cũng có thể gây ra deadblock / starvation**, kể cả **livelyness (safety)**.

