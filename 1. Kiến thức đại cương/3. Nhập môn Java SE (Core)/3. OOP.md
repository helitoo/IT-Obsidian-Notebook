
# Lớp & Đối tượng

## Cấu trúc chương trình Java

### Package

Package là nhóm các lớp và các thành phần khác có liên quan với nhau (do người lập trình quy định) được tổ chức chung lại để dễ quản lý, tránh trùng tên, và tái sử dụng mã.

Cũng có thể nói, package là folder chứa các file `.java`.

Tên package phải thể hiện cấu trúc folder.

**VD**:
```
src/
 └─ myapp/
      └─ utils/
           └─ Helper.java -- myapp.utils
```
Thì `Helper.java` phải khai báo package là `package myapp.utils;`.

Mỗi file `.java` chỉ được phép khai báo một lớp có phạm vi `public`. Tên lớp này phải trùng với tên file.

**VD**:
`Main.java`
```java
package myPck;

public class Main {
	// ...
}
```

### Giao tiếp giữa các lớp

Các lớp trong cùng package có thể được gọi *tự do* theo phạm vi truy cập.

Lớp `Aclass` muốn truy cập đến lớp `Bclass` khác package (theo phạm vi truy cập) thì phải có thêm *`import`*:

**VD**: Import class `Bclass` (hoặc thành viên cụ thể của `Bclass`) trong package `Bpackage`.
```java
import Bpackage.Bclass; //Bpackage.Bclass.Bmember
```

**VD**: Import toàn bộ class từ `Bpackage`.
```java
import Bpackage.*; // Bpackage.*
```

**Chú ý**:
- Cú pháp `import` chỉ có phạm vi trực tiếp đến package được chỉ thị, **không bao gồm các package con** (nếu có).
- `import` chỉ có ý nghĩa thực khi compile.
- Package **`java.lang.*`** luôn được mặc định import sẵn.

## Khai báo

**Khai báo lớp**:
```java
public class cls {
	// ...
}
```

**Khai báo đối tượng**:
```java
cls obj = new cls();
```

# Các thành phần của lớp

## Thuộc tính & Phương thức

Thuộc tính có thể coi là các biến của lớp, có cú pháp khai báo tương tự như [[2. Cú pháp cơ bản#Kiểu dữ liệu|khai báo biến thông thường]].

Phương thức có thể coi là các hàm của lớp. VD:
```java
void myMt(...) {
	// ...
}
```
Method có thể nhận tham số không mặc định, nạp chồng và `return` giống như C++.

## Truy cập các thành phần của lớp

Sử dụng toán tử `.` như C++:
```java
myObj.myAtt     // Truy cập thuộc tính
myObj.myMt(...) // Truy cập phương thức
```

Bạn chỉ được phép truy cập các thành phần của lớp tùy theo phạm vi truy cập của lớp đó. Có các phạm vi truy cập là:

| Phạm vi     | Truy cập từ cùng lớp hoặc lớp con | Truy cập từ cùng package | Truy cập từ package khác (kế thừa) | Truy cập từ package khác (không kế thừa) |
| ----------- | --------------------------------- | ------------------------ | ---------------------------------- | ---------------------------------------- |
| `public`    | OK                                | OK                       | OK                                 | OK                                       |
| `protected` | OK                                | OK                       | OK                                 |                                          |
| Mặc định    | OK                                | OK                       |                                    |                                          |
| `private`   | OK                                |                          |                                    |                                          |

**Lưu ý**:
- Lớp con có toàn quyền truy cập các thành phần của lớp cha.
- Lớp cha muốn truy cập các thành phần của lớp con phải dựa vào *phạm vi truy cập của lớp con*.

## Các thành phần đặc biệt của Java

| Từ khóa    | Đối với class         | Đối với thuộc tính                                                                                                                      | Đối với phương thức                                                                                                                     |
| ---------- | --------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| `static`   | --                    | Tất cả đối tượng có chung thành phần `static` có giá trị giống nhau .<br><br>Tức `static` là thành phần của lớp, không phải của object. | Tất cả đối tượng có chung thành phần `static` có giá trị giống nhau .<br><br>Tức `static` là thành phần của lớp, không phải của object. |
| `final`    | Không được kế thừa.   | Không được thay đổi (*const*).                                                                                                          | Không thể ghi đè (kế thừa).                                                                                                             |
| `abstract` | Không thể tạo object. | --                                                                                                                                      | Buộc phải được ghi đè (kế thừa).                                                                                                        |

## Từ khóa `this`

`this` được dùng để chỉ đối tượng hiện tại của class.
`super` được dùng để chỉ class cha của class hiện tại (trong kế thừa).

**VD**:
```java
public class Main {
	int x;
	public modifyX(int x) {
		this.x = x; // this x là chỉ thuộc tính x của Main
	}
}
```

`this(...)` tương đương với gọi constructor.
**VD**:
```java
public class Main {
	int modelYear;
	String modelName;
	
	public Main(int modelYear, String modelName) {
	    this.modelYear = modelYear;
	    this.modelName = modelName;
	}
	
	public Main(String modelName) {  
		this(2020, modelName);
	}
}
```
Khi gọi `this(2020, modelName)`, nó sẽ gọi constructor có 2 tham số tương ứng.

## Phương thức khởi tạo (Constructor)

Constructor là một phương thức đặc biệt:
- Không có kiểu dữ liệu (nên không có giá trị trả về).
- Có tên trùng với tên class.
- Có phạm vi `public`.
Được dùng để khởi tạo giá trị cho các thuộc tính của class.

Mỗi lần 1 object được khởi tạo, JVM sẽ gọi constructor đầu tiên. Constructor mặc định là rỗng.

**VD**: Constructor không tham số:
```java
public class Main {
  int x;

  public Main() {
    x = 5;
  }
}

// Main urObject = new Main();
```

**VD**: Constructor có tham số:
```java
public Main(int x) {
    this.x = x;
}

// Main urObject = new Main(5); ==> x = 5
```

## Phương thức chính (main)

Mỗi class phải có duy nhất một phương thức `public static void` là `main`.
- `main` là phương thức được gọi **để chạy đầu tiên** khi chương trình bắt đầu thực thi.
- `main` được gọi mà **không cần khởi tạo object thuộc lớp chứa nó**.

**VD**:
`Main.java`
```java
public class Main {
    public static void main(String[] args) {
        // ...
    }
}
```
Trong đó, `args` là đối số, nhận khi gọi `Main` qua CLI.

```javac
java Main "Hello world" user
```
Khi đó, `args = ["Hello word", "user"]`.

## Enum class

Enum là một dạng class đặc biệt chỉ chứa các hằng giá trị (`public`, `static`, `final`). Mỗi giá trị này là một đối tượng của enum.

**VD**:
```java
public class Main {
	enum Level {
		LOW,
		MEDIUM,
		HIGH
	}
	
	public static void main(String[] args) {
		System.out.println(Level.MEDIUM); // MEDIUM
	}
}
```

**VD**: Duyệt các giá trị của enum bằng `.values()`:
```java
for (Level myVar : Level.values()) {
	System.out.println(myVar);
}
```
```sh
LOW
MEDIUM
HIGH
```

# Các cấu trúc đặc biệt của lớp

## Wrapper class

Các [[2. Cú pháp cơ bản#Các kiểu primitive|primitive type]] không phải object. Wrapper class là các lớp *hỗ trợ thao tác với biến primitive như là một object*.

Các wrapper class đều được định nghĩa trong package `java.lang`.

| Primitive Data Type | Wrapper Class |
| ------------------- | ------------- |
| `byte`              | `Byte`        |
| `short`             | `Short`       |
| `int`               | `Integer`     |
| `long`              | `Long`        |
| `float`             | `Float`       |
| `double`            | `Double`      |
| `boolean`           | `Boolean`     |
| `char`              | `Character`   |

Một phương thức khá hay của các wrapper là các phương thức tĩnh dùng để ép kiểu dữ liệu:
- `Integer.toString(val)`: Ép `int` sang `String`.
- `Integer.parseInt(val)`: Ép sang `int`. Tương tự với `.parseFloat()`, `.parseLong()`,...

## Lớp lồng nhau (Inner class)

Lớp có thể được khai báo lồng trong lớp khác, gọi là *Inner classes*. Inner class có ý nghĩa gôm dữ liệu tạm thời, không có vai trò lớn trong thiết kế hệ thống.

Cú pháp truy cập: `outerClass.innerClass`.

**VD**: Non-static inner class -> Cần tạo object khi dùng:
```java
class OuterClass {
	int x = 10;
	
	private class InnerClass {
		int y = 5;
	}
}

public class Main {
	public static void main(String[] args) {
		OuterClass myOuter = new OuterClass();
		OuterClass.InnerClass myInner = myOuter.new InnerClass();
		// System.out.println(myInner.y + myOuter.x);
	}
}
```

**VD**: Static inner class -> Không cần tạo object khi dùng, do `static` không phải thành phần của object:
```java
class OuterClass {
	int x = 10;
	
	static class InnerClass {
		int y = 5;
	}
}

public class Main {
	public static void main(String[] args) {
		OuterClass.InnerClass myInner = new OuterClass.InnerClass();
		// System.out.println(myInner.y);
	}
}
```

## Lớp kế thừa (Inheritance) & Đa hình (Polymorphism)

#### Từ khóa `extends`

Một lớp có thể kế thừa một lớp khác (sử dụng các thành phần của lớp khác (Mặc định và `protected`)) bằng từ khóa `extends`.

**Lưu ý**:
- Nếu 1 lớp là `final` thì không thể được kế thừa.
- Lớp con có thể ghi đè các thành phần của cha (*đa hình*).

**VD**: Tính kế thừa:
```java
class Vehicle {
	protected String brand = "Ford";
	public void honk() {
		System.out.println("Tuut, tuut!");
	}
}

class Car extends Vehicle {
	// Car có thể truy cập đến các thành phần của Vehicle
}
```

**VD**: Tính đa hình:
```java
class Animal {
	public void animalSound() {
		System.out.println("The animal makes a sound");
	}
}

class Pig extends Animal {
	public void animalSound() { // Ghi đè Animal.animalSound
		System.out.println("The pig says: wee wee");
	}
}
```

#### Từ khóa `super`

- `this` / `this()`: Ám chỉ class hiện tại.
- `super` / `super()`: Ám chỉ class cha.

**VD**:
```java
class Pig extends Animal {
	public void animalSound() {
		super.animalSound();
	}
}
```

## Tính trừu tượng (`abstract` - `extends`)

Lớp trừu tượng là lớp **không thể có object**.
-> Lớp trừu tượng buộc phải có kế thừa và đa hình.

Phương thức trừu tượng là phương thức **không thể gọi và chỉ có prototype**.
-> Phương thức trừu tượng buộc phải bị lớp con ghi đè.

**VD**:
```java
// Lớp trừu tượng
abstract class Animal {
	public abstract void animalSound(); // hoặc public void animalSound đều được
	
	public void sleep() {
		System.out.println("Zzz");
	}
}
```

## Lớp thuần ảo (`interface` - `implements`)

Lớp thuần ảo là lớp mà mọi phương thức đều trừu tượng.

**VD**:
```java
// Lớp thuần ảo
interface Animal {
	public void animalSound();
	public void run();
}

// Kế thừa bằng implements
class Pig implements Animal {
	public void animalSound() {
		System.out.println("The pig says: wee wee");
	}
	
	public void sleep() {
		System.out.println("Zzz");
	}
}
```

## Dependency injection

**Dependency** của class A là những class mà A cần có để thực thi (*tight-coupling*).

**Dependency injection** là giảm sự phụ thuộc của class A với các dependency của nó (*light-coupling*).

**VD**: Dependency:
```java
public class Girl{
    private Bikini outfit; // Bikini là dependency của Girl
    
    public Girl(){
      outfit = new Bikini();
    }
}
```

**VD**: Dependency injection:
```java
public interface Outfit {
  public void wear();
}

public class Bikini implements Outfit {
  public void wear() {
    // ...
  }
}

public class Girl{
    private Outfit outfit;
    
    public Girl(Outfit anything){
      this.outfit = anything;
    }
}

public class Main {
  public static void main(String[] args) {
    Outfit bikini = new Bikini();
    
    Girl ngocTrinh = new Girl(bikini);
    // Girl đã bớt lệ thuộc vào Bikini
    // Do ta có thể truyền bất kỳ class nào (thuộc Outfit) vào Girl, không nhất thiết là Bikini
  }
}
```












