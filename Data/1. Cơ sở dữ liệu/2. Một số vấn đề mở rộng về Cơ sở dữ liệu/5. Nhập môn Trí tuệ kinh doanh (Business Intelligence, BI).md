
```insta-toc
---
title:
  name: Mục lục
  level: 1
  center: false
exclude: ""
style:
  listType: number
omit: []
levels:
  min: 1
  max: 6
---

# Mục lục

1. Mối quan hệ giữa cơ sở dữ liệu và các giao dịch kinh doanh
    1. Giao dịch (Transaction) và cơ chế lock
    2. Hệ thống xử lý giao dịch trực tuyến (Online Transaction Processing, OLTP)
    3. Trí tuệ kinh doanh (Business Intelligence, BI)
2. Data warehouse và Data mart
    1. Data warehouse
    2. Data mart
3. Dimensional model
    1. Tính chuẩn hóa và Phi chuẩn hóa của các mô hình dữ liệu
    2. Tổng quan về trúc của dimensional model
    3. Các cấu trúc đặc biệt của dimensional model
    4. Slowly changing dimension (SCD)
4. Cube
    1. Multidimensional model
    2. Agreeate table
    3. Sparse matrix
    4. Một số thao tác với cube
5. OLAP (Online analytical processing)
```

**Tài liệu tham khảo**:
- [Elmasri & Navathe | Fundamentals of Database system](https://drive.google.com/file/d/1jnxKwO-DRqrkgJ9iIkre8l4jLHQNeCwZ/view).
- [Microsoft Ignite | Dimensional modeling in Fabric Data Warehouse](https://learn.microsoft.com/en-us/fabric/data-warehouse/dimensional-modeling-overview).

# Mối quan hệ giữa cơ sở dữ liệu và các giao dịch kinh doanh

## Giao dịch (Transaction) và cơ chế lock

Trong [[4. Transact-SQL (T-SQL)|T-SQL]], **giao dịch (transaction)** là một nhóm các lệnh SQL để thực hiện một nhiệm vụ nào đó.

VD:
```sql
BEGIN TRANS;

	-- AccountID 1 chuyển tiền
    UPDATE Accounts
    SET Balance = Balance - 1000
    WHERE AccountID = 1;

	-- AccountID 2 nhận tiền
    UPDATE Accounts
    SET Balance = Balance + 1000
    WHERE AccountID = 2;

IF @@ERROR <> 0
    ROLLBACK TRANS;
ELSE
    COMMIT TRANS;
```
Transaction trên mô phỏng thao tác nhận - chuyển tiền đơn giản giữa ID `1` và ID `2`. Nếu `1` chuyển tiền thành công và `2` nhận tiền thành công thì xác nhận transaction thành công (`COMMIT`), ngược lại là thất bại và hoàn tác lại transaction (`ROLLBACK`).

Khi nhiều transaction xảy ra đồng thời thì nguy cơ xung đột lẫn nhau là lớn, nên T-SQL đã đề ra cơ chế **lock**. Khi một transaction đang thao tác trên dữ liệu, nó sẽ đặt khóa để ngăn giao dịch khác làm thay đổi dữ liệu đó (gây xung đột).

Đặc điểm:
1. Mỗi transaction chỉ giữ 1 lock. SQL Server sẽ tự cấp khóa cho transaction đang thực thi.
2. **Blocking**: Khi 2 transaction có nguy cơ bị xung đột, transaction đang thực thi mà có khóa thì được ưu tiên thực thi trước, transaction kia phải đợi.
3. **Deadblock**: Trong trường hợp cả 2 transaction chờ nhau vô hạn, không chọn được transaction để thực thi thì SQL Server sẽ chọn 1 transaction để thực thi.

Có 3 loại lock:
1. **Shared lock (S)**: Khi 1 transaction đang `SELECT` dữ liệu mà dùng lock này thì các transaction khác không thể ghi đè dữ liệu đó.
2. **Exclusive lock (X)**: Khi 1 transaction đang `INSERT`, `UPDATE` hay `DELETE` mà dùng lock này thì các transaction khác không thể đọc hay ghi dữ liệu đó.
3. **Update lock (U)**: Khi 1 transaction vừa `SELECT`, vừa `INSERT`, `UPDATE` hay `DELETE` mà dùng lock này thì các transaction khác không được truy cập vào dữ liệu đó.

## Hệ thống xử lý giao dịch trực tuyến (Online Transaction Processing, OLTP)

**OLTP** là những hệ thống xử lý giao dịch dựa trên cơ chế *transaction*.
Các OLTP có một số đặc điểm sau:
1. Các giao dịch thường **ngắn và thay đổi liên tục**. Giao dịch càng ngắn, hiệu năng càng **cao**.
2. Có thể xử lý **rất nhiều user** thao tác cùng lúc.
3. Chỉ cần **chỉnh sửa ít hàng** trong cơ sở dữ liệu.
4. Dữ liệu có **kích thước khá nhỏ**.

## Trí tuệ kinh doanh (Business Intelligence, BI)

**BI (Analytic system, Informative system)** là quá trình Tích hợp dữ liệu toàn doanh nghiệp (enterprise-wide data) vào một kho dữ liệu duy nhất (data store) để người dùng có thể chạy các truy vấn (ad hoc queries) hoặc tạo báo cáo (reports), từ đó phân tích dữ liệu.

BI giúp các nhà kinh doanh có dữ liệu đã được tổ chức để đưa ra **quyết định kinh doanh tốt hơn**.

Một số đặc điểm:
1. Dữ liệu được đưa vào BI sau khi làm sạch theo **chu kỳ**, VD như mỗi sau giờ làm việc.
2. Chỉ phục vụ cho **một vài user**.
3. Phải **truy vấn rất nhiều hàng** trong cơ sở dữ liệu.
4. Kho dữ liệu có **kích thước rất lớn**, thậm chí lưu cả những dữ liệu trong quá khứ.

# Data warehouse và Data mart

![](https://www.certia.net/wp-content/uploads/2020/03/SSIS_ETL-1.jpg)

## Data warehouse

Data warehouse là 1 database chứa toàn bộ dữ liệu của doanh nghiệp.

**Mục tiêu**:
1. Làm cơ sở dữ liệu phục vụ cho báo cáo, phân tích.
2. Lưu trữ thông tin lịch sử vận hành doanh nghiệp.
3. Qua đó đưa ra các quyết định phát triển doanh nghiệp.

**Đặc điểm**:
1. **Subject-Oriented / Consitency**: Warehouse *tập trung lưu trữ các dữ liệu cần thiết cho phân tích dữ liệu*, không ưu tiên lưu trữ các dữ liệu thể hiện quan hệ giữa các bảng (xem thêm ở phần *Dimensional model*).

2. **Integrated / Atomicity**: Dữ liệu của warehouse đến từ *nhiều nguồn khác nhau*, có thể là nhiều database, mỗi database có thể theo một mô hình dữ liệu riêng, một hệ quản trị riêng,... Khi dữ liệu từ các nguồn đó được chuyển vào warehouse có thể xảy ra mâu thuẫn, vì:
	1. Định dạng dữ liệu giữa các nguồn không giống nhau.
	2. Dữ liệu không sạch, không chuẩn hóa.
	3. Dữ liệu kém chất lượng.
	Vì thế cần một quy trình chuyển đổi các dữ liệu từ nhiều nguồn vào một nguồn đích: [[5.1. Nhập môn data pipelining]].

3. **Time-variant**: Warehouse có thể *chứa tất cả phiên bản của dữ liệu* theo dòng thời gian.

4. **Non-volatile / Durable**: Dữ liệu trong warehouse *không bị thay đổi hoặc xóa đi* mà chỉ có thể thêm vào và truy vấn.

Các nguồn dữ liệu của warehouse thường là:
1. **Production data**: Là nguồn lưu các giao dịch thường ngày của doanh nghiệp, thường là OLTP.
2. **Archived data**: Là nguồn lưu trữ các dữ liệu cũ, lỗi thời so với thời điểm hiện tại. Chỉ dùng cho các phân tích về chiến lược dài hạn để phát triển doanh nghiệp.
3. **Internal data**: Là nguồn lưu các dữ liệu phát sinh nội bộ trong tổ chức, như dữ liệu báo cáo, dữ liệu thống kê,...
4. **External data**: Là nguồn lưu các dữ liệu bên ngoài doanh nghiệp, VD như các dữ liệu mở về thống kê thị trường, thống kê khách hàng,...


**Tại sao không dùng view mà dùng warehouse?**

Cả hai đều:
1. Cung cấp dữ liệu phục vụ cho truy vấn là chính.
2. Được thiết kế để cung cấp góc nhìn theo **chủ đề** (subject-oriented), giúp người dùng cuối dễ truy cập hơn là xem dữ liệu thô.

Điểm khác nhau:

|                         | View                                                                                                                     | Warehouse                                                                                                                                               |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Cách lưu trữ**        | Tạm thời. Khi gọi view thực chất là gọi truy vấn trên database gốc. Khi database gốc thay đổi thì view cũng sẽ thay đổi. | Dữ liệu lưu trong warehouse độc lập, không phụ thuộc vào các nguồn dữ liệu khác.                                                                        |
| **Mô hình**             | Chủ yếu là relational model.                                                                                             | Dimensional model (Warehouse). Khi truy vấn thì dùng cube (Multidimensional warehouse)                                                                  |
| **Tốc độ**              | **Không thể tự tạo index riêng.** Tốc độ phụ thuộc vào cơ sở dữ liệu gốc.                                                | **Có thể được tối ưu hóa và tạo index riêng** để truy vấn cực nhanh.                                                                                    |
| **Tiềm năng phân tích** | Hạn chế.                                                                                                                 | Chuyên dùng cho phân tích kinh doanh với những thao tác thống kê phức tạp.                                                                              |
| **Quy mô**              | Mỗi view có nguồn gốc từ 1 database duy nhất thông qua 1 lệnh truy vấn.                                                  | 1 warehouse có thể sinh ra nhiều cube khác nhau. Warehouse là kho dữ liệu khổng lồ, tổng hợp từ nhiều nguồn khác nhau thông qua quy trình ETL phức tạp. |

## Data mart

**Data mart** là một phần của warehouse.

Trên thực tế, mỗi data mart chỉ chứa một loại dữ liệu cụ thể của một bộ phận trong công ty. Sau đó, các developer mới hợp nhất các mart lại thành warehouse. Tức là phát triển theo hướng **bottom-up**.

Cách tiếp cận này tiết kiệm hơn nhiều so với phát triển warehouse ngay từ đầu, bởi vì các đặc điểm ưu trội sau của mart:
1. Kích thước nhỏ, phạm vi hẹp hơn warehouse.
2. Dễ thiết kế, bảo trì, quản lý.
3. Chi phí phát triển thấp, thời gian phát triển nhanh hơn warehouse.

# Dimensional model

## Tính chuẩn hóa và Phi chuẩn hóa của các mô hình dữ liệu

**Relational model** có **tính chuẩn hóa (Normalization)**, tức là không có hàng nào trong bảng trùng nhau, mô tả được quan hệ giữa các đối tượng, phù hợp với OLTP vì OLTP có thao tác thêm, sửa, xóa là chính, nếu không có tính chuẩn hóa thì dữ liệu được thêm, sửa, xóa sẽ không đảm bảo độ chính xác.

**Dimensional model** có **tính phi chuẩn hóa (Denormalization)** bằng cách ghép các bảng lại thành ít bảng hơn, không thể hiện quan hệ giữa các bảng mà *tập trung phục vụ cho thao tác truy vấn* nên phù hợp với data warehouse.

Chuẩn hóa thuận tiện cho thêm, sửa, xóa dữ liệu vì nó có các ràng buộc dữ liệu, nhưng khó khăn khi truy vấn, và ngược lại với phi chuẩn hóa.

VD: Xét bảng sau: **CUSTOMER**:

| CustomerId | Name        | Street              | City |
| ---------- | ----------- | ------------------- | ---- |
| 3          | Bao Minh    | Nam Ky Khoi Nghia   | HCMC |
| 4          | Dong Nguyen | Cach mang Thang Tam | HCMC |
| 5          | Thai Bao    | Nam Ky Khoi Nghia   | HCMC |
| 6          | Nhat Tan    | Cach mang Thang Tam | HCMC |

Ta thấy dữ liệu ở `Street` và `City` bị trùng nhau, vì các customer có thể có cùng địa chỉ, nên bảng trên có tính **phi chuẩn hóa**.

Để tránh sự trùng nhau đó, cần tách thông tin của customer và address thành 2 đối tượng riêng biệt, đưa bảng về **chuẩn hóa**:


![[normalization-demornalization.svg]]

>[!IMPORTANT] Denormalization (hay Dimensional model) phù hợp với warehouse cho truy vấn vì
>1. Đơn giản, thuận tiện, không cần viết SQL phức tạp.
>2. Trực quan, dữ liệu được trình bày dễ thấy, không cần đối chiếu so sánh quan hệ nhiều bảng cùng lúc.

## Tổng quan về trúc của dimensional model

Dimensional model gồm 2 loại bảng:
1. **Dimension table**: Gồm có các loại thuộc tính sau:
	1. **Thuộc tính định danh (textual)**: Thường có **kiểu chuỗi**, dùng để định danh các hàng dữ liệu trong fact table. VD: *Tên sản phẩm, địa chỉ, nhân viên,...*
	2. **Khóa chính**: Thường chỉ có 1 thuộc tính.
	3. **Khóa ngoại**: Trong một số cấu trúc đặc biệt *(giới thiệu sau)*.

2. **Fact table**: Gồm có các loại thuộc tính sau:
	1. **Thuộc tính định lượng (Measure)**:
		- Thường có **kiểu số** (*phù hợp với các agreeate function*). VD: *doanh thu, lợi nhuận,...* Các thuộc tính này thể hiện *độ chi tiết (granularity)* của mô hình.
		- Fact table *có thể không có measures*. Khi đó, ta truy vấn thông qua các hàm như `COUNT`, `MIN`, `MAX` thay vì `AVG`, `SUM`,...
	2. **Thuộc tính nhật ký (Audit attribute)**:
		- Lưu lại thông tin về sự thay đổi của các hàng. VD: `AuditCreatedDate`, `AuditLastModifiedDate`, `AuditCreatedBy`,...
		- **Historical tracking attributes** *(tìm hiểu thêm ở phần sau)* là một dạng audit, cho phép lưu lại các mốc thời điểm dữ liệu của dimension table thay đổi.
	3. **Khóa chiều (Dimension key)**:
		- Là các thuộc tính tham chiếu đến các dimension table. Tức khóa chiều là khóa ngoại của fact table.
		- Số lượng khóa chiều cũng là *số chiều (dimensionality)* của mô hình.
	4. **Khóa chính**:
		- Có thể có hoặc không, thường được ngầm hiểu là tất cả dimension key.

Cấu trúc của dimensional model còn được gọi là **Cấu trúc hình sao (Star schema)**: Có một hay nhiều fact table ở trung tâm, liên kết với nhiều dimension table.

VD: `SALE_FACT` là fact table, chứa các thuộc tính định lượng là `Quantity`, `TotalPrize`, các thuộc tính còn lại là khóa ngoại tham chiếu đến các dimension table khác nhau. `SALE_FACT` không có khóa chính riêng mà có khóa chính là tổ hợp các khóa ngoại.

![[star_schema.svg]]

![[dimensional-model.png]]
Lý do mô hình được gọi là dimensional model: Vì nó bao gồm các chiều (dimension table) và giao giữa các các mốc trên các chiều đó chính là các thuộc tính định lượng (nếu có).

## Các cấu trúc đặc biệt của dimensional model

---
**Cấu trúc hình hoa tuyết (Snowflake schema)**: Các dimension table có thể được phân cấp ra thành nhiều dimension table con:

VD: Snowflake schema:
![[snowflake_schema.svg]]

---
**Galaxy schema / Fact constellation / Conformed dimension**: Một số dimension table có thể được dùng chung bởi nhiều fact table.

VD: Ở fact `SALE_FACT` và `INVENTORY_FACT` đều cần lưu trữ thông tin về `DATE` và `PRODUCT`, đây là 2 conformed dimension.

![[conformed.svg]]

---
**Out-trigger dimension**: Là việc các dimension có quan hệ với nhau, giúp chuẩn hóa và tái sử dụng các thuộc tính chung.

VD: Cả `CUSTOMER` và `SALEPERSON` đều cần các thuộc tính của `ADDRESS`, nên có thể tách `ADDRESS` thành bảng riêng để tái sử dụng.

![[outtrigger.svg]]


---
**Role-playing dimension**: Một số dimension có thể được tham chiếu bởi nhiều cột của fact table, mỗi cột có một vai trò khác nhau.

VD: Ở `SALE_FACT` cần lưu thông tin về `OrderDate`, `ShipDate`,... nhưng bản chất của 2 thuộc tính này có thể được gộp chung thành `DATE`, bao gồm các thuộc tính chung như `day`, `month`,...

![[roleplaying.svg]]

---
**Degenerate dimension**: Dimension table chứa các thuộc tính định danh. Nhưng nếu không cần nhiều thuộc tính định danh thì không cần phải tạo dimension table riêng mà chỉ cần đưa thẳng vào fact table. Những thuộc tính định danh nhưng nằm trong fact table thì gọi là degenerate dimension.

VD: Ở đây, `SaleId` là thuộc tính định danh duy nhất cho mỗi hàng của `SALE_FACT`, và cũng không có thuộc tính nào khác kèm theo, nên có thể bỏ luôn bảng `SALEORDER`.

![[degenerate.svg]]

---
**Junk dimension**: Junk dimension là dimension table nhưng không có ý nghĩa định danh, được tạo ra để lưu trữ những giá trị rời rạc trong fact table. Những thuộc tính rời rạc này vô tình làm phình to kích thước fact table, giảm hiệu quả truy vấn, nên cần đưa chúng sang một bảng khác là junk dimension.

VD:
**CUSTOMER_FACT**:

| CustomerId | DateId   | Quantity | Sex | IsStudent |
| ---------- | -------- | -------- | --- | --------- |
| 1          | 20250101 | 53       | F   | 1         |
| 2          | 20250102 | 64       | M   | 0         |
| 3          | 20250103 | 24       | F   | 0         |
| 4          | 20250104 | 5        | F   | 1         |
| ...        | ...      | ...      | ... | ...       |

Có thể thấy các thuộc tính `Sex` (chỉ nhận `F` và `M`) và `IsStudent` (chỉ nhận `1` và `0`) là những thuộc tính rời rạc, cần đưa sang junk như sau:

![[junk.svg]]

---
**Multivalued dimension**: Là những thuộc tính mà trên cùng một hàng có thể chứa nhiều giá trị, nhưng số lượng thuộc tính không có tính động nên cần một dimension là cầu nối (**Bridge dimension**) để giải quyết vấn đề này.

VD:
**SALE_FACT**:

| SaleId | CustomerId | DateId   | Quantity | DiscountType |
| ------ | ---------- | -------- | -------- | ------------ |
| 1      | 6          | 20250101 | 53       | ?            |
| 2      | 7          | 20250102 | 64       | ?            |
| 3      | 8          | 20250103 | 24       | ?            |
| 4      | 9          | 20250104 | 5        | ?            |
|        | ...        | ...      | ...      | ...          |

Ở đây, một khách hàng có thể nhận nhiều loại khuyến mãi (`DiscountType`) khác nhau.
Xử lý bằng cách tạo một bảng cầu nối trung gian giữa `SALE_FACT` và `DISCOUNT`, giống như một mối n-n trong relational model.

![[multivalued.svg]]

## Slowly changing dimension (SCD)

SCD là hiện tượng dữ liệu trong **dimension table thay đổi**.
Do dimensional model không chuyên dùng cho sửa dữ liệu, nên cần có những cách đặc biệt để sửa dữ liệu:

---
1. **SCD type 1: Ghi đè (Overwrite)**:
	- Là **ghi đè** lại dữ liệu cần sửa trên toàn bộ hàng.
	- Nhược điểm là không lưu lại lịch sử thay đổi dữ liệu, dẫn đến sai lệch khi phân tích dữ liệu.

---
2. **SCD type 2: Thêm thuộc tính theo dõi lịch sử (Historical tracking attributes)**:
	- Các thuộc tính mới có thể là `Date`, `IsCurrent` hay `Version`,... Cũng có thể chú thích trực tiếp sự thay đổi vào dữ liệu (**label**). VD: *"John (US)" -> thêm "John (China)"*.
	- Khi dữ liệu thay đổi, việc cần làm là thêm một hàng mới chứa dữ liệu mới đó và cập nhật các hàng cũ (nếu cần).

>[!NOTE]
>Nên tránh thay đổi theo SCD 2 quá nhiều lần, vì sẽ làm tăng độ phức tạp khi phân tích dữ liệu.
>Nếu có thuộc tính nào đó dự tính sẽ bị thay đổi nhiều, hãy đưa nó vào fact table.

---
3. **SCD type 3: Theo dõi lịch sử hạn chế (Limit history)**:
	- Thay vì lưu lại toàn bộ lịch sử thay đổi dữ liệu như SCD 2, ta chỉ lưu lại một số điểm mốc cần thiết trong lịch sử thay đổi cho phân tích dữ liệu.
	- VD: Chỉ ghi nhận thay đổi điểm đầu và điểm cuối, bỏ qua các mốc thay đổi trung gian.

# Cube

## Multidimensional model

**Cube** là tập hợp một số dữ liệu và một số thuộc tính được trích xuất từ warehouse, được dùng trực tiếp cho thống kê kinh doanh, còn gọi là **dữ liệu cấp lá (leaf-level data)**.

Các cube thuộc một **multidimensional database** và được quản lý bởi **multidimensional database management system (MDBMS)**.

## Agreeate table

**Agreeate table** là bảng chứa các dữ liệu thống kê (tạo ra từ agreeation function). Do khối lượng warehouse quá lớn, việc truy vấn trực tiếp dữ liệu có thể làm giảm hiệu năng, do đó cần xây dựng sẵn các agreeate table.

Các công cụ OLAP thường tự động đề xuất các loại agreeate function phù hợp để xây dựng agreeate table.

## Sparse matrix

Cho cube với các dimension là Product, Store, Time. Giả sử: Có 1000 sản phẩm,100 cửa hàng, 365 ngày -> Cube sẽ có = 1000 × 100 × 365 = 36.5 triệu ô dữ liệu.

Nhưng trong thực tế:
- Không phải sản phẩm nào cũng bán ở mọi cửa hàng.
- Không phải ngày nào cũng có giao dịch.
-> Có thể chỉ 2-5% ô là có giá trị thực. Cube bị sparse (thưa).

>[!IMPORTANT]
>Cube là **không gian đa chiều đầy đủ**, với mỗi chiều đều có một số giá trị định lượng tương ứng. Dù cho trên thực tế có thể không có giá trị định lượng nào.

**Ma trận thưa** là kỹ thuật lưu trữ chỉ những ô trong cube mà thực sự có dữ liệu, bỏ qua tất cả các ô trống. Nó được gọi là thưa vì hầu hết các ô trong không gian đa chiều này đều trống rỗng.

## Một số thao tác với cube

1. **Pivot**:
	- Đảo các chiều cho nhau, giống như xoay cái hộp để nhìn sang mặt khác.
	- VD: Bạn có thể xem *Sản phẩm theo Địa điểm*, *Địa điểm theo Thời gian*,...

2. **Slice**:
	- Cố định một chiều để nhìn vào các chiều còn lại.
	- VD: Xem *Thông tin tất cả các sản phẩm với chiều thời gian là "Quý II"*.

3. **Drill-Down / Roll-Up**
    - **Drill-Down:** Đi từ tổng quan vào chi tiết.
	    VD: Bạn thấy "Miền Bắc" bán rất chạy, bạn **khoan xuống** để xem chi tiết: Hà Nội bán bao nhiêu? Hải Phòng bán bao nhiêu? Thậm chí từng cửa hàng ở Hà Nội bán ra sao?
        
    - **Roll-Up:** Ngược lại, từ chi tiết đi lên tổng quan.
	    VD: Bạn gộp doanh số của tất cả các cửa hàng ở Hà Nội lại để thành con số của Hà Nội, rồi gộp các tỉnh lại thành con số của Miền Bắc.



# OLAP (Online analytical processing)

OLAP là hệ thống xử lý phân tích dữ liệu từ warehouse. Có 3 loại:
1. **Relational OLAP (ROLAP)**: Truy vấn dữ liệu trực tiếp từ các relational database. Phù hợp với dữ liệu lớn, mang tính linh hoạt cao.
2. **Multidimensional OLAP (MOLAP)**: Lưu trữ dữ liệu đã được tổng hợp sẵn trong các cube. Cho tốc độ truy vấn cực nhanh nhưng phù hợp hơn với khối lượng dữ liệu vừa phải.
3. **Hybrid OLAP (HOLAP)**: Dựa trên một loại model lai giữa relational và multidimensional.

|                       | ROLAP                                                            | MOLAP                                                                         |
| --------------------- | ---------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Cấu trúc lưu trữ**  | Relational database.                                             | Cube (Multidelational database).                                              |
| **Quy mô dữ liệu**    | Phù hợp với **khối lượng dữ liệu lớn**.                          | Thường dùng cho **khối lượng dữ liệu có giới hạn** (vừa và nhỏ).              |
| **Tốc độ truy vấn**   | Tốc độ truy cập **chậm hơn** do phải dùng trực tiếp dữ liệu gốc. | Tốc độ truy cập **rất nhanh** vì dữ liệu đã được tổng hợp sẵn trong các cube. |
