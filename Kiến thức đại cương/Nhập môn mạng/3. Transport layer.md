
```insta-toc
---
title:
  name: Mục lục
  level: 1
  center: false
exclude: ""
style:
  listType: number
omit: []
levels:
  min: 1
  max: 6
---

# Mục lục

1. Giao thức TCP / UDP
2. Truyền dữ liệu đáng tin cậy
    1. Checksum
    2. Các chiến lược xây dựng kênh truyền tin đáng tin cậy (RDT)
        1. Các chiến lược dựa trên nguyên lý stop-and-wait
        2. Các chiến lược dựa trên nguyên lý pipelining
3. Các chiến lược vận chuyển gói tin của TCP
    1. Chiến lược RDT
    2. Chiến lược điều khiển luồng (flow-control)
    3. Chiến lược quản lý kết nối
    4. Chiến lược điều khiển tắc nghẽn (AIMD)
```

# Giao thức TCP / UDP

Tầng vận chuyển có 2 giao thức chính là TCP và UDP.

|                     | TCP<br>(Transmission control protocol)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | UDP<br>(User datagram protocol)                                                                                |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| **Nền tảng**        | [[4. Network layer#Mạch ảo và Mạch gói tin\|Mạch ảo (Hướng kết nối)]].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | [[4. Network layer#Mạch ảo và Mạch gói tin\|Mạch gói tin (Phi kết nối)]] (các gói tin được đối xử độc lập).    |
| **Cấu trúc header** | **Các trường**:<br>- `Source port`.<br>- `Dest port`.<br>- `Sequence number`: Số thứ tự của byte đầu tiên của segment. `Seq` đầu tiên do OS khởi tạo bằng *thuật toán*.<br>- `ACK number`: `Seq` của segment tiếp theo.<br>- `Recieve window`: Số lượng byte mà bên nhận có thể nhận thêm.<br>- `Checksum`.<br>- `Urgent pointer`.<br>- `TCP options`.<br><br>**Các cờ**:<br>- `ACK`: Đánh dấu đây là segment chứa `ACK number`.<br>- `SYN`: Đánh dấu đây là segment đề nghị *mở kết nối*.<br>- `FIN`: Đánh dấu đây là segment đề nghị *đóng kết nối*.<br>- `URG`, `PSH`, `RST`.<br><br>=> Server có thể thực hiện nhiều TCP connection vì mỗi connection đều định danh được nguồn và đích. | **Các trường**:<br>- `Source port`.<br>- `Dest port`.<br>- `Length`: Độ dài toàn segment.<br>- `Checksum`.<br> |
| **Đặc điểm**        | - **Point-to-Point**: 1 bên gửi - 1 bên nhận.<br>- Truyền tin cậy.<br>- **Full duplex**: 1 host có thể vừa nhận vừa gửi cùng lúc (*luồng 2 chiều*).<br>- **Handshaking**: 2 host kết nối trước khi truyền.<br>- **Flow control**: Giảm tốc độ khi tắc nghẽn.                                                                                                                                                                                                                                                                                                                                                                                                                                | - Ngược lại với TCP.<br><br>- Thiết lập đơn giản, nhỏ gọn.<br><br>- Tốc độ cao.                                |
| **Ví dụ**           | Email, Web, FTP, Remote login.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | DNS, VoIP, game online, streaming video.                                                                       |

>[!important]
>UDP **best effort** - nỗ lực truyền tin nhưng không đảm bảo chính xác.
>Tuy vậy, UDP **vẫn có bước kiểm tra lỗi khi truyền gói tin**.

>[!important]
>- **TCP/UDP** *không* đảm bảo **thông lượng / băng thông, độ trễ**.
>- Để giải quyết vấn đề bảo mật, thường thông qua **TLS (Transport layer security)** ở **tầng ứng dụng** để *mã hóa dữ liệu trước khi gửi*.

>[!important]
>- Cả TCP/UDP đều dùng **địa chỉ IP để định tuyến**.
>- Nhưng trên header thì chỉ dùng **số port** để mở kết nối.

>[!note] Khi nào dùng TCP, khi nào dùng UDP?
>- Các ứng dụng yêu cầu **độ chính xác** -> **TCP**.
>- Các ứng dụng yêu cầu **tốc độ, băng thông, độ trễ**,... -> **UDP**.

Một số protocol tầng Ứng dụng dựa trên TCP/UDP:

| Protocol                                      | Dựa trên                | Port | Chức năng                                                         | Đặc điểm                                                                                                  |
| --------------------------------------------- | ----------------------- | ---- | ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| **HTTP**<br>(*Hypertext transfer protocol*)   | TCP<br><br>UDP (HTTP/3) | 80   | Lấy dữ liệu về từ server.                                         | - Có 2 dạng là bền vững và không bền vững.<br><br>- Msg *có thể* ở dạng **ASCII 8-bit** (`\n`, `\r`,...). |
| **SMTP**<br>*(Simple Mail Transfer Protocol)* | TCP                     | 25   | Gửi mail vào mailbox của người nhận.                              | - Bền vững.<br><br>- Msg phải ở dạng **ASCII 7-bit** (`CRLF.CRLF`,...).                                   |
| **POP**<br>*(Post Office Protocol)*           | TCP                     | 110  | Tải mail về client rồi xóa mail đó ở mailbox.                     |                                                                                                           |
| **IMAP**<br>*(Internet Mail Access Protocol)* | TCP                     | 143  | Cũng như POP, nhưng mail vẫn còn ở mailbox chứ không tự động xóa. |                                                                                                           |
| **DNS**<br>(*Domain name system*)             | TCP / UDP               | 53   | Gửi query để tra cứu IP và response để trả về IP.                 |                                                                                                           |

# Truyền dữ liệu đáng tin cậy

>[!important]
>Nguyên lý cơ bản của RDT là **Truyền lại khi phát hiện gói tin bị lỗi, bị mất thứ tự, mất gói tin**.
>ACK/NACK, checksum chỉ là các công cụ *kiểm tra* phục vụ RDT, không phải nguyên lý của RDT.

## Checksum

**Quy trình**:
- Bên gửi:
	- Chia dữ liệu thành các chuỗi 16 bit. Nếu không đủ 16 bit thì bù bit `0` vào trước chuỗi.
	- Tính **tổng bù 1 (1’s complement sum)** trên từng chuỗi.
	- Đưa vào header.

- Bên nhận:
	- Cộng tất cả (bao gồm checksum).
	- Nếu kết quả giống trường `checksum` của header, gói tin *có khả năng có lỗi*; ngược lại thì *chắc chắn có lỗi.*

>[!important]
>- Checksum **không thể sửa lỗi**.
>- Trong các trường hợp như **dữ liệu bị đảo**, checksum không kiểm tra được lỗi (*vì `A + B` = `B + A`*).

VD:

Gói tin:
- Source Port: `0x1F90` (8080)
- Dest Port: `0x0045` (69)
- Length: `0x001C` (28 byte)
- Data: `0x54657374`.

Cộng dồn các giá trị
```
0x1F90 + 0x0045 + 0x001C + 0x54657374 = 0x546593DD
```

Lấy bù 1 (đảo bit):
```
0xAB9A6C22
```

Vậy, checksum là `0xAB9A6C22`.

Khi nhận, bên nhận cũng tính checksum và nếu cũng ra `0xAB9A6C22` thì dữ liệu được cho là không có lỗi.

## Các chiến lược xây dựng kênh truyền tin đáng tin cậy (RDT)

### Các chiến lược dựa trên nguyên lý stop-and-wait

**Stop-and-wait** là sau khi bên gửi gửi 1 gói tin:
- Router sẽ đợi cho đến khi bên nhận gửi lời xác nhận segment (có lỗi hay không).
- Sau đó bên gửi mới tiếp tục gửi segment khác.

Các cơ chế dùng trong stop-and-wait:

| Phiên bản   | Vấn đề được khắc phục         | Phương pháp                                                                                                 |
| ----------- | ----------------------------- | ----------------------------------------------------------------------------------------------------------- |
| **RDT 1.0** |                               |                                                                                                             |
| **RDT 2.0** | Giải quyết **gói hỏng**.      | Dùng **ACK/NACK và checksum**:<br>- Trả về ACK khi gói đúng.<br>- Trả về NACK khi gói sai, đợi gửi lại gói. |
| **RDT 2.1** | Giải quyết **ACK/NACK hỏng**. | **Đánh số thứ tự** cho gói: ACK/NACK hỏng là ACK/NACK có số thứ tự *bị trùng*.                              |
| **RDT 2.2** | Giải quyết **NACK hỏng**.     | **Chỉ dùng ACK**: ACK lỗi là ACK *bị trùng*.                                                                |
| **RDT 3.0** | Giải quyết **mất gói**.       | **Dùng timer**: Nếu đợi lâu quá mà bên gửi không thấy ACK thì tự động gửi lại.                              |

### Các chiến lược dựa trên nguyên lý pipelining

**Pipeling** cho phép bên gửi gửi hàng loạt gói tin thay vì gửi từng gói một như *stop-and-wait*.

Chúng ta sẽ tìm hiểu 3 thuật toán: *Go-back-end (GBN), Selective repeat (SR) và thuật toán của TCP*.

3 thuật toán trên có điểm chung:
1. Bên gửi **gửi liên tiếp một số lượng gói** cố định theo kích thước **cửa sổ trượt (Send window)** mà không cần chờ ACK cho mỗi gói.
2. Trong trường hợp thông thường, mỗi gói gửi đi sẽ nhận về 1 gói ACK tương ứng.
3. Mỗi một ACK được xác nhận, cửa sổ trượt dịch 1 đơn vị.
4. Thao tác *gửi lại gói* được thực thi khi **timeout**. Đôi khi, gói được gửi đi trước timeout, gọi là **Early timeout**.

Riêng với TCP, gói được gửi lại khi:
1. Timeout, early timeout.
2. **Truyền lại nhanh**: Khi nhận được 3 gói ACK giống nhau (**Duplicated ACK**).

Minh họa cơ chế xử lý mất gói và mất gói ACK của từng thuật toán:

|         | Go-back-end (GBN)         | Selective repeat (SR)    | RDT của TCP                                                       |
| ------- | ------------------------- | ------------------------ | ----------------------------------------------------------------- |
| Mất gói | ![[GBN-loss-segment.png]] | ![[SR-loss-segment.png]] | ![[TCP-loss-segment.png]]<br>Nửa đầu giống GBN, nửa sau giống SR. |
| Mất ACK | ![[GBN-loss-ACK.png]]     | ![[SR-loss-ACK.png]]     | ![[GBN-loss-ACK.png]]<br>Giống GBN.                               |

Như đã thấy, GBN và TCP có thể **tự xác nhận các ACK bị mất**. Cơ chế này được gọi là **ACK tích lũy (Cummulative ACK)**.

Hoạt ảnh mô phỏng:
- [GBN](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html).
- [SR](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html).

>[!important]
>Dù gói tin bị mất nhưng **Seq vẫn tăng bình thường**, vì gói tin đó vẫn gửi được.

# Các chiến lược vận chuyển gói tin của TCP

## Chiến lược RDT

**Công thức tính timeout**: Tính theo thứ tự sau:

$$
\begin{align}
&\text{RTT}_\text{sample}=t_\text{nhận ACK}-t_\text{gửi}\tag{1}\\
&\text{RTT}_\text{dev}=(1-\beta)\times\text{RTT}_\text{dev}+\beta\times|\text{RTT}_\text{sample}-\text{RTT}_\text{estimated}|;\quad\beta=0.25\tag{2}\\
&\text{RTT}_\text{estimated}=(1-\alpha)\times\text{RTT}_\text{estimated}+\alpha\times\text{RTT}_\text{sample};\quad\alpha=0.125\tag{3}\\
&\text{TimeoutInterval}=4\times\text{RTT}_\text{dev}+\text{RTT}_\text{estimated}\tag{4}
\end{align}
$$
Trong đó:
- **Sample RTT**: Là RTT thực, khác nhau ở mỗi lần đo.
- **Deviation of RTT (Safety margin)**: Là biên độ dao động của Sample RTT.
- **Estimated RTT**: Là giá trị trung bình của RTT.
- Nếu thời gian đợi ACK vượt quá đại lượng **TimeoutInterval** thì tính là timeout.

**Công thức tính giá trị trường `Seq` và `ACK`**:
$$
\begin{align}
\text{Seq}_i&=\text{Seq}_{i-1}+L_{i-1}\\
\text{ACK}_i&=\text{Seq}_{i+1}=\text{Seg}_i+L_i
\end{align}
$$

>[!caution]
>Cần phải hiểu **`ACK` là `Seq` tiếp theo mà host này muốn nhận**.

## Chiến lược điều khiển luồng (flow-control)

Điều khiển luồng là điều khiển số byte mà host nhận được. Phù hợp khi tốc độ xử lý của host không tương thích với tốc độ xử lý của transport layer.

Các bước điều khiển luồng:
1. Khi thấy dữ liệu đến, bên nhận lưu tạm nó vào buffer.
2. Bên nhận thông báo dung lượng còn trống cho buffer thông qua trường **Recieve window** (số byte mà bên nhận có thể nhận được).
3. Buffer sẽ gửi một lượng dữ liệu tối đa bằng recieve window cho server.

>[!important]
>Recieve window chính là cửa sổ trượt trong nguyên lý RDT bằng pipelining.

## Chiến lược quản lý kết nối

| Mở kết nối - 3-ways handshake                                                                                               | Đóng kết nối - 4-ways handshake                                                                                                                                                                                        |
| --------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Chỉ có client** mới có thể yêu cầu mở kết nối.                                                                            | **Cả client hoặc server** đều có thể yêu cầu đóng kết nối.                                                                                                                                                             |
| Dùng **cờ SYN**.                                                                                                            | Dùng **cờ FIN - Finish**.                                                                                                                                                                                              |
| - **Bên gửi**: Muốn mở kết nối, gửi SYN segment.<br>- **Bên nhận**: Trả lại SYN/ACK segment.<br>- **Bên gửi**: Gửi lại ACK. | - **Bên gửi**: Muốn đóng kết nối, gửi FIN segment.<br>- **Bên nhận**: Trả lại ACK và gửi nốt các segment chưa được gửi. Sau đó mới gửi lại FIN segment lần 2 là xác nhận đóng kết nối.<br>- **Bên nhận**: Gửi lại ACK. |
| ![[3-ways-handshake.png]]                                                                                                   | ![[4-ways-handshake.png]]                                                                                                                                                                                              |

>[!note]
>Căn cứ vào cờ **flag** của segment mà biết đó là segment gì.

>[!note]
>Nguyên lý là:
>- Mở kết nối - 3-ways-handshake: **Dùng SYN**.
>- Đóng kê nối - 4-ways-handshake: **Dùng FIN**.
>
>Để đảm bảo RDT, mỗi lần nhận segment thì phải trả về ACK để kết thúc.

## Chiến lược điều khiển tắc nghẽn (AIMD)

**Nguyên nhân xảy ra tắc nghẽn**:
1. Tốc độ gửi, truyền tin hữu hạn.
2. Bộ nhớ hữu hạn.

Gọi:
- **cwnd (Congestion window)**:
	- Tổng kích thước lớn nhất được phép gửi các gói tin.
	- Đơn vị là **MSS (Maxium segment size, kích thước gói tin tối đa)**.
	- Tốc độ gửi tỷ lệ thuận với cwnd.

- **ssthread (Slow start threshold)**:
	- Ngưỡng kết thúc giai đoạn slowstart và chuyển sang congestion avoidance.
	- Thường là một ngưỡng khá lớn.

**AIMD (Thăm dò băng thông)**: Bên gửi liên tục tăng tốc độ truyền cho đến khi việc mất gói tin xảy ra, sau đó giảm tốc độ truyền dựa trên sự kiện mất.

**3 giai đoạn điều khiển tắc nghẽn**:
1. **Slow start**: Ban đầu, cwnd = 1 MSS. Sau đó gấp đôi sau mỗi RTT:
$$ \text{cwnd}_i = \text{cwnd}_{i-1} \times 2 $$

2. **Congestion avoidance**:
	- Khi cwnd ≥ ssthread, cwnd chỉ tăng 1 SSM sau mỗi RTT:
$$ \text{cwnd}_i = \text{cwnd}_{i-1} + 1 $$

3. **Fast recovery**:
	1. **Khi bên gửi nhận được 3 ACK trùng nhau**, TCP cho rằng có gói tin bị mất, đẩy nhanh cwnd để gửi lại:
$$ \text{cwnd}_i = \frac{\text{cwnd}_{i-1}}{2} + 3 $$
	2. **Khi timeout**, mạng đã bị nghẽn do gói tin không gửi được, quay về slow start.
$$ \text{cwnd}_i = 1 $$

Điều kiện kích hoạt 3 trạng thái:
```mermaid
graph TD

ss[Slow start]
fr[Fast recovery]
ca[Congestion avoidance]

ss -- Nhận 3 ACK trùng --> fr
fr -- Timeout --> ss
fr -- Nhận ACK mới --> ca

ca -- Timeout --> ss
ss -- cwnd >= ssthread --> ca
ca -- Nhận 3 ACK trùng --> fr

```

VD: Cho biểu đồ:

```mermaid
xychart-beta
    x-axis "RTT" [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]
    y-axis "cwnd" 1 --> 17
    line [1,2,4,8,16,1,2,4,8,9,10,11,12,13,14,7,8,9,10,1,2,4]
```
- **Slow start**: Những đoạn *uốn cong cấp số nhân* (1 - 5, 6 - 9, 21 - 22).
- **Congestion avoidance**: Những đoạn *thẳng tăng tuyến tính* (9 - 15, 16 - 19).
- **Fast recovery**: Những đoạn *thẳng giảm tuyến tính* (15 - 16).
