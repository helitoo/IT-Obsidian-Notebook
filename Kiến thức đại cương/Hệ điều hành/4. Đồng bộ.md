
```insta-toc
---
title:
  name: Mục lục
  level: 1
  center: false
exclude: ""
style:
  listType: number
omit: []
levels:
  min: 1
  max: 6
---

# Mục lục

1. Race condition
2. Các giải pháp đồng bộ
3. Liveness - Deadblock
```

# Race condition

Race condition là hiện tượng xảy ra khi **nhiều process cùng truy cập vào một vùng nhớ đồng thời** (**Vùng tranh chấp - Critical section / Critical region**).

>[!note]
>**Vùng tranh chấp** là một vùng nhớ hay một đoạn mã bậc cao tại vùng nhớ đó.

**Hậu quả**: Dữ liệu bị sai, không nhất quán.

**Bài toán Consumer - Producer**:
- Consumer process: Liên tục tăng biến `count`.
- Producer process: Liên tục giảm biến `count`.
Lúc này, vùng tranh chấp là biến `count`.

**Bài toán cấp phát PID**:
- Giả sử có 2 process được gọi bởi `fork()` và sẽ được cấp PID bởi biến `next_available_pid`.
- Nếu 2 process được fork cùng lúc thì sẽ xảy ra mâu thuẫn và 1 PID có thể được cấp 2 lần.
Lúc này, vùng tranh chấp là `next_available_pid`.

# Các giải pháp đồng bộ

**Tiêu chuẩn của một lời giải tốt** gồm:
1. **Loại trừ tương hỗ (Mutual exclusion)**: Nếu process P đang thực thi tại vùng tranh chấp của nó, thì Q (và mọi process khác) phải bị chặn lại ở vùng tranh chấp của chúng, cho đến khi P thoát ra.
2. **Tiến triển (Progress)**: Một process ở ngoài vùng tranh chấp thì *không được ngăn cản các process khác* vào vùng tranh chấp.
3. **Chờ đợi giới hạn (Bounded waiting)**: Mỗi process phải *chờ để được vào vùng tranh chấp* trong một khoảng thời gian cố định.

>[!important]
>- 2 process A và B có không gian địa chỉ riêng, chỉ có thể xung độ về resources chứ không xung đột về địa chỉ.
>- Vùng tranh chấp của A là 1 đoạn mã thuộc A.
>- Do đó, **A không bao giờ có thể thực thi tại vùng tranh chấp của B**, nên đây **KHÔNG là một phạm trù của bài toán đồng bộ**.

**Phân loại lời giải dựa trên sự hỗ trợ từ phần mềm / phần cứng**:
1. **Dựa trên phần mềm (ngắt)**:
	- Dựa vào các thuật toán.
2. **Dựa trên phần cứng (Test and Set, `automic`...)**:
	- Cần một vài phần cứng đặc biệt.
	- -> Khá *phức tạp* và *không thể truy cập* được bởi dev của các chương trình ứng dụng.

**Phân loại lời giải dựa trên sự hỗ trợ từ OS**:
1. **Busy waiting**:
	- Không cần OS, do dev triển khai.
2. **Sleep & Wake-up**:
	- OS cung cấp system call để *ngắt và đánh thức* process khi không thể / có thể đưa process vào vùng tranh chấp.
	- -> Gây *lãng phí tài nguyên* CPU vì liên tục kiểm tra điều kiện chờ đợi tiến vào vùng tranh chấp.

**Một số giải pháp**:

| Tên                                | Dựa trên                        | Nguyên lý                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Nhược điểm                                                                                      |
| ---------------------------------- | ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------- |
| **Giải pháp sơ khai 1**            | Phần mềm.<br><br>Busy waiting   | - Sử dụng 2 lệnh hợp ngữ đơn nguyên (*không thể bị cắt ngang*) là `load` và `store`.<br><br>- Duy trì một biến chung **`turn`** trỏ đến process có quyền vào vùng tranh chấp.                                                                                                                                                                                                                                                                                                                                                                                      | Không **progess** và **bounded waiting**.                                                       |
| **Giải pháp sơ khai 2**            | Phần mềm.<br><br>Busy waiting   | - Cũng sử dụng `load` và `store`.<br><br>- Duy trì một biến chung **`flag`** cho phép các process bật `flag` để yêu cầu vào vùng tranh chấp.                                                                                                                                                                                                                                                                                                                                                                                                                       | Không **mutual exclusion**.                                                                     |
| **Giải pháp Peterson**             | Phần mềm.<br><br>Busy waiting.  | - Là kết hợp giữa giải pháp 1 và giải pháp 2:<br>  + `flag`: Thể hiện các process *muốn vào* (ưu tiên 2).<br>  + `turn`: Thể hiện các process *được vào* (ưu tiên 1).<br><br>- Đối với kiến trúc máy tính hiện đại, để gia tăng hiệu năng thì CPU / compiler sẽ tự **sắp xếp lại các lệnh** `load`, `store`,... => Cần *memory barrier*.                                                                                                                                                                                                                           | Thứ tự hoạt động có thể bị sai vì đặc điểm CPU hiện đại.<br><br>Các tính chất khác thì đảm bảo. |
| **Mutex lock**                     | Phần cứng.<br><br>Sleep-Wakeup. | Mutex lock là một ổ khóa.<br>  - Process muốn vào -> Cần `acquire()` để lấy khóa.<br>  - Process muốn ra -> Cần `release()` để trả khóa.<br><br>`acquire()` và `release()` chỉnh sửa một biến chung `available`. Nếu `available = false` thì các process khác không thể vào.                                                                                                                                                                                                                                                                                       | Lãng phí CPU do **busy waiting** (các process phải đợi nhiều).                                  |
| **Spinlock**                       | Phần cứng.<br><br>Busy waiting. | Nếu process không lấy được khóa thì sẽ **xoay vòng kiểm tra liên tục** cho đến khi vào được.                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Lãng phí CPU do **busy waiting** (các process phải đợi nhiều).                                  |
| **Semaphore**                      | OS.<br><br>Busy waiting.        | Semaphore bao gồm:<br>  - Biến `s` thể hiện số lượng process được vào **trừ đi 1**.<br>  - Hàng đợi `q` chứa các process đang đợi.<br><br>Biến `s` được kiểm soát bởi 2 hàm sau:<br>  - `wait(s)`: `s--` (chạy khi process vào).<br>  - `signal(s)`: `s++` (chạy khi process ra).<br><br>- **Binary semaphore**: Khi `s` chỉ có 2 giá trị `0` và `1`.<br>- **Counting semaphore**: Là dạng tổng quát của `s`, dùng cho nhiều resource bị tranh chấp. 1 counting semaphore có thể được thực hiện bởi nhiều binary semaphore.<br><br>Mutex lock là 1 loại semaphore. |                                                                                                 |
| **Semaphore<br>(no busy waiting)** | OS.<br><br>Sleep-Wakeup.        | Các process không được vào sẽ bị **block**.<br><br>Các process sẽ được vào sẽ được **wake-up**.                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                 |
| **Monitor**                        | OS.<br><br>Sleep-Wakeup.        | Monitor là một cơ chế giúp **tự động hóa việc sử dụng mutex lock / semaphore**, các dev không cần điều khiển thủ công nữa.<br><br>Monitor gồm có:<br>  - **Các biến nội bộ**: Được khai báo bên trong monitor và chỉ được truy cập bởi các thủ tục của monitor. Trong đó, **condition variable** đảm bảo việc process có thể vào vùng tranh chấp không.<br>  - **Các thủ tục**: Được định nghĩa bởi dev.                                                                                                                                                           |                                                                                                 |
| **Condition variable**             | OS.<br><br>Sleep-Wakeup.        | Condition variable là một công cụ bổ trợ trong monitor, cho phép process **`wait(s)`** và **`signal(s)`** khi thỏa mãn một số điều kiện.<br><br>Mỗi condition có một queue riêng chứa các process đang đợi.<br><br>Cần dev định nghĩa từ trước.                                                                                                                                                                                                                                                                                                                    |                                                                                                 |

**Cơ chế memory barrier**: Là một instruction mà bắt buộc **mọi thay đổi trong bộ nhớ phải được thông báo đến mọi CPU**. Nhờ vậy, các lệnh `load`, `store`,... sẽ được thực thi tuần tự thay vì chồng chéo lên nhau.

**Cơ chế memory model**:
- **Memory model**: Là mô hình hoạt động của bộ nhớ, bao gồm cách thức quản lý & truy xuất đến các vùng nhất.
- Có 2 loại:
	- **Mô hình bộ nhớ được sắp xếp mạnh**: Các thay đổi trên bộ nhớ sẽ *được toàn bộ processor biết*. Là nền tảng của *Memory barrier*.
	- **Mô hình bộ nhớ được sắp xếp yếu**: Ngược lại.

>[!important]
>- Vùng bộ nhớ định nghĩa các lệnh `wait(s)`, `signal(s)` là **vùng tranh chấp (Critical region)**. Đây là các lệnh không thể bị ngắt giữa chừng.
>- `wait`, `for`, `signal`,... là các lệnh kiểm soát resources.
>- Binary semaphore **KHÔNG** phải mutex vì mutex ràng buộc process, semaphore ràng buộc tài nguyên được truy cập.

# Liveness - Deadblock

**Liveness** là tập các đặc điểm mà hệ thống phải thỏa mãn để *các process được chạy*.

**Deadblock** là tình trạng *các process chờ nhau vĩnh viễn, không vào được vùng tranh chấp.

>[!important]
>Bất kỳ giải pháp đồng bộ nào **cũng có thể gây ra deadblock / starvation**, kể cả **livelyness (safety)**.

