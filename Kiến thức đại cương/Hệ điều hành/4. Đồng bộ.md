
```insta-toc
---
title:
  name: Mục lục
  level: 1
  center: false
exclude: ""
style:
  listType: number
omit: []
levels:
  min: 1
  max: 6
---

# Mục lục

1. Race condition
2. Các giải pháp đồng bộ sơ khai
3. Các giải pháp đồng bộ cấp cao
```

# Race condition

Race condition là hiện tượng xảy ra khi *nhiều process cùng truy cập vào một vùng nhớ đồng thời* (**Vùng tranh chấp - Critical section**).

**Hậu quả**: Dữ liệu bị sai, không nhất quán.

VD:

**Bài toán Consumer - Producer**:
- Consumer process: Liên tục tăng biến `count`.
- Producer process: Liên tục giảm biến `count`.
Lúc này, vùng tranh chấp là biến `count`.

**Bài toán cấp phát PID**:
- Giả sử có 2 process được gọi bởi `fork()` và sẽ được cấp PID bởi biến `next_available_pid`.
- Nếu 2 process được fork cùng lúc thì sẽ xảy ra mâu thuẫn và 1 PID có thể được cấp 2 lần.
Lúc này, vùng tranh chấp là `next_available_pid`.

# Các giải pháp đồng bộ sơ khai

**Yêu cầu của lời giải**:
1. **Loại trừ tương hỗ (Mutual exclusion)**: Khi một process đang thực thi trong vùng tranh chấp thì *không có process nào khác được thực thi tại đó*.
2. **Tiến triển (Progress)**: Một process ở ngoài vùng tranh chấp thì *không được ngăn cản các process khác vào vùng tranh chấp*.
3. **Chờ đợi giới hạn (Bounded waiting)**: Mỗi process phải *chờ để được vào vùng tranh chấp trong một khoảng thời gian cố định*.

**Phân loại lời giải dựa trên sự hỗ trợ của phần cứng**:
1. **Dựa trên phần mềm / Ngắt**: Sử dụng các thuật toán -> Gây *lãng phí tài nguyên* CPU khi liên tục kiểm tra điều kiện chờ đợi tiến vào CS (busy waiting).
2. **Dựa trên phần cứng**: Cần một vài phần cứng đặc biệt -> Khá *phức tạp* và *không thể truy cập* được bởi dev của các chương trình ứng dụng.

**Phân loại lời giải theo sự hỗ trợ của OS**:
1. **Busy waiting**: Không cần OS, sử dụng kỹ thuật lập trình để process đợi để vào cùng tranh chấp.
2. **Sleep & Wake up** \[Hiện đại]: Cần OS cung cấp system call để *tạm dừng* process khi không thể đưa process này vào vùng tranh chấp - *đánh thức* process để đưa vào vùng tranh chấp.

**Một số giải pháp**:

| Tên                     | Dựa trên  | Nguyên lý                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ----------------------- | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Giải pháp sơ khai 1** | Phần mềm  | - Sử dụng 2 lệnh hợp ngữ đơn nguyên (không thể bị cắt ngang) là `load` và `store`.<br><br>- Các process sử dụng chung một biến `turn`, biến này chỉ ra process nào được quyền vào vùng tranh chấp. Ban đầu, `turn` = `i`. Sau khi process thứ `i` vào vùng tranh chấp xong thì trả về `i + 1`...                                                                                                                                                                                                                              |
| **Giải pháp sơ khai 1** | Phâ mềm   | - Cũng sử dụng `load` và `store`.<br><br>- Các process sử dụng chung một biến `boolean flag[n]`. Nếu `flag[i]` = `true` thì process `i` sẵn sàng vào vùng tranh chấp.                                                                                                                                                                                                                                                                                                                                                         |
| **Giải pháp Peterson**  | Phần mềm  | - Là kết hợp giữa giải pháp 1 và giải pháp 2.<br><br>- Đối với kiến trúc máy tính hiện đại, để gia tăng hiệu năng, **thứ tự các lệnh sẽ được sắp xếp lại**, VD như sắp xếp lại thứ tự `load`, `store`, `flag`,...                                                                                                                                                                                                                                                                                                             |
| **Memory Barrier**      | Phần cứng | - **Memory model**: Là mô hình hoạt động của bộ nhớ, bao gồm cách thức quản lý & truy xuất đến các vùng nhất.<br><br>Gồm 2 loại là:<br>- **Mô hình bộ nhớ được sắp xếp mạnh**: Các thay đổi trên bộ nhớ sẽ được toàn bộ processor biết.<br>- **Mô hình bộ nhớ được sắp xếp yếu**: Ngược lại.<br><br>- **Memory barrier**: Là một instruction mà bắt buộc mọi thay đổi trong bộ nhớ phải được thông báo đến mọi processor. Nhờ vậy, mỗi các cặp thao tác `load` - `store` được thực thi tuần tự chứ không chồng chéo lên nhau. |

# Các giải pháp đồng bộ cấp cao

Do những hạn chế của các giải pháp phần mềm và phần cứng, nên thực tế thì người ta dùng các **giải pháp phần mềm cấp cao** sau:

| Tên                           | Nguyên lý                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ----------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Mutex lock**                | - Mutex lock là một ổ khóa.<br><br>- 1 process muốn vào vùng tranh chấp thì phải dùng `acquire()` để lấy khóa từ OS. Sau khi sử dụng xong CPU thì sẽ `release()` để trả khóa lại cho OS.<br><br>- Nội dung của `acquire()`: Đặt `available = false`, ngăn các process khác vào vùng tranh chấp.<br>- Nội dung của `release()`: Đặt `available = true`.<br><br>=> Lãng phí CPU do **busy waiting** (các process phải đợi nhiều).                                   |
| **Spinlock**                  | - Thay vì cho các process đợi, OS sẽ đưa các process vào **block**.<br><br>- Khi nào cần, các process sẽ được **wake up**.                                                                                                                                                                                                                                                                                                                                        |
| **Semaphore**                 | - Semaphore là tập hợp các mutex lock. Bản chất semaphore là một biến `s` được gắn với queue chứa các process đang đợi.<br><br>+ `wait(s)`: Nếu `s` <= 0 thì process phải chờ. Với mỗi process vào vùng tranh chấp thì `s` -= 1.<br>+ `signal(s)`: Sau khi process ra khỏi vùng tranh chấp thì `s` += 1.<br><br>Mutex lock sơ khai là một dạng **Binary semaphore** với `s` = `available` = 0 hoặc 1.<br><br>**Counting semaphore** là dạng tổng quát của binary. |
| **Semaphore no busy waiting** | Sử dụng cơ chế **block** - **wakeup** như *Spinlock*.                                                                                                                                                                                                                                                                                                                                                                                                             |
| **Monitor**                   | Monitor là một dạng nâng cấp, trừu tượng cao của semaphore, gồm có:<br>- **Các biến nội bộ**: Được khai báo bên trong monitor và chỉ được truy cập bởi các thủ tục của monitor.<br>- **Các thủ tục của monitor**: Được định nghĩa bởi dev.<br><br>1 process vào monitor bằng cách gọi các thủ tục của monitor, hệ thống *tự lock và unlock mà không cần dev*.<br><br>=> Tại mỗi thời điểm chỉ có 1 process trong monitor -> Cần condition.                        |
| **Condition variable**        | Condition variable là một công cụ bổ trợ trong monitor, cho phép process **wait** và **signal** khi thỏa mãn một số điều kiện.<br><br>Mỗi condition có một queue riêng chứa các process đang đợi.<br><br>Cần dev quản lý thủ công.                                                                                                                                                                                                                                |
| **Liveness**                  | **Liveness** là tập các đặc điểm mà hệ thống phải thỏa mãn để các process thực sự chạy. Khi process phải chờ thì OS không liveness mà chuyển qua **deadblock**.<br><br>Deadblock là tình trạng có nhiều hơn 1 process đang đợi.                                                                                                                                                                                                                                   |
|                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |



















