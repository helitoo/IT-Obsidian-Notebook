
```insta-toc
---
title:
  name: Mục lục
  level: 1
  center: false
exclude: ""
style:
  listType: number
omit: []
levels:
  min: 1
  max: 6
---

# Mục lục

1. Tổng quan
    1. Deadblock
    2. Điều kiện xảy ra deadblock
    3. Các phương pháp giải quyết deadlock
2. Mô hình hóa bài toán tắc nghẽn
    1. Đồ thị cấp phát resource (Resource allocation graph, RAG)
    2. Giải thuật Banker
```

# Tổng quan

## Deadblock

**Deadblock** là hiện tượng có một tập các process bị block, mỗi process giữ một số resource và đang chờ thêm các resource khác mà các process khác trong tập đang giữ. Sự tắc nghẽn có thể diễn ra **vô hạn**.

## Điều kiện xảy ra deadblock

1. **Loại trừ tương hỗ (Mutual exclusion)**: Có resource nào đó được giữ theo **non-sharable mode** (không được dùng bởi nhiều process).
2. **Giữ và chờ cấp thêm resource (Hold & Wait)**:
	- Một process đang giữ ít nhất 1 resource và đợi thêm resource do process khác giữ.
	- Các process nắm resource mà các process khác đang cần, tạo ra một **chu trình đợi**.
3. **Không trưng dụng (Non-preemptive)**: Resources chỉ có thể được **hoàn trả** bởi process đang giữ nó.  OS không thể cưỡng ép thu hồi.

## Các phương pháp giải quyết deadlock

1. **Ngăn deadblock**: Ngăn (ít nhất) một trong 4 điều kiện xảy ra deadlock:
	1. **Ngăn Hold & Wait**: Block process nếu không thể cấp phát.
	2. **Ngăn Preemption**: Thu hồi resources của process.
	3. **Ngăn chu trình đợi**: Đánh số thứ tự cho các resources.
	-> Không thể ngăn hoặc không cần ngăn **mutual exclusion**.
	-> Không cần biết resources tối đa mà process muốn.
	-> Không đảm bảo hiệu suất sử dụng resources.

2. **Tránh deadblock**:
	- Các process cần **cung cấp thông tin về resource nó cần và tính trạng allocation** để OS dự đoán khả năng có deadblock.
	-> Đảm bảo hiệu suất sử dụng resources.

3. **Phát hiện deadblock**: Nếu xảy ra deadblock thì cố gắng giải quyết.

4. **Bỏ qua deadblock**: Nếu xảy ra deadblock, OS quá tải và ngưng hoạt động.

# Mô hình hóa bài toán tắc nghẽn

## Đồ thị cấp phát resource (Resource allocation graph, RAG)

-> Dùng để **Phát hiện deadblock**.

Là 1 đồ thị **có hướng**, với tập đỉnh $V$ và tập cạnh $E$.
- $V$ gồm 2 loại:
	- Tập processes: $P=\{P_1,P_2,... , P_n\}$.
	- Tập resources: $R=\{R_1, R_2,...,R_n\}$.
- $E$ gồm 2 loại:
	- Process $P_i$ yêu cầu resource $R_j$: $P_i\rightarrow R_j$.
	- resource $R_j$ đang bị giữ bởi process $P_i$: $R_j\rightarrow P_i$.

Số lượng process tối đa được quyền nắm giữ 1 resource được gọi là **số lượng instance**. Ký hiệu là chấm `.`.

**Nhận biết deadblock từ RAG**:
1. RAG *không* chứa chu trình -> *Không* có deadblock.
2. RAG *có* chu trình -> *Có thể* có deadblock:
	1. Mỗi resource trong chu trình chỉ có 1 thực thể -> Deadblock.
	2. Mỗi resource trong chu trình có nhiều thực thể -> Có thể có deadblock. *Số lượng thực thể càng nhiều thì khả năng deadblock càng thấp*.

**Chuỗi an toàn**: Là thứ tự thực thi các process sao cho không xảy ra deadblock.

## Giải thuật Banker

-> Dùng để **Tránh deadblock**.

Yêu cầu các process phải khai báo $\text{Need}$ là lượng resource tối đa nó cần, OS dựa vào đây để cấp phát.
