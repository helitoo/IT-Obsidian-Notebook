
```insta-toc
---
title:
  name: Mục lục
  level: 1
  center: false
exclude: ""
style:
  listType: number
omit: []
levels:
  min: 1
  max: 6
---

# Mục lục

1. Giới thiệu
2. Cài đặt bộ nhớ ảo
3. Cấp phát frame
4. Vấn đề Thrashing
    1. Thrashing
    2. Locality
    3. Working set
```

# Giới thiệu

Bộ nhớ ảo là một kỹ thuật cho phép **xử lý 1 process mà không cần nạp toàn bộ vào bộ nhớ vật lý**.

**Ưu điểm**:
- Số lượng process trong bộ nhớ nhiều hơn.
- Process có thể dùng nhiều bộ nhớ hơn bộ nhớ vật lý của nó -> Tăng **đa chương**.
- Giảm nhẹ công việc của dev. Dev chỉ cần quan tâm đến logical address.

**Nhược điểm**:
- **Chậm** hơn bộ nhớ vật lý.

# Cài đặt bộ nhớ ảo

Có 2 kỹ thuật:
- **Phân trang theo yêu cầu (Demand Paging)**:
	- Các trang của process *chỉ được nạp vào bộ nhớ chính khi được yêu cầu*.
	- => Cần phải truy xuất bộ nhớ nhiều lần -> *Tốn thời gian*.
	- Khi *trang không tồn tại (Invalid bit)* -> Phần cứng ngắt (*page-fault trap*) -> kích hoạt **page-fault service routine (PFSR)**.
	- **Các bước của PFSR**:
		1. Đưa process về *blocked*.
		2. Tìm frame trống (*trong bước này thì các process khác vẫn có thể được cấp CPU để thực thi*):
			1. Nếu tìm thấy, cập nhật lại page table, đưa process vào ready.
			2. Nếu không tìm thấy (*Lỗi trang, Page fault*), dùng thuật toán thay trang nhớ để thay 1 trang (*victim page*) cho process này. Một số giải thuật thay trang:
				1. **FIFO (First-in First-out)**: Thay thế trang **đã được dùng** sớm nhất. Có thể gây ra **nghịch lý Belady**: Càng cấp nhiều frame, page fault càng tăng.
				2. **OPT (Optimal)**: Thay thế trang **dự định** sẽ dùng xa nhất hoặc không dùng nữa.
				3. **LRU (Least Recently Used)**: Thay thế trang **hiện chưa dùng** lâu nhất.

- **Phân đoạn theo yêu cầu (Demand Segmentation)**.

>[!note] Chú ý phân biệt với các kỹ thuật Placement của Dynamic partitioning
>1. **Best-fit**: Chọn khối trống **nhỏ nhất**.
>2. **Worst-fit**: Chọn khối trống **lớn nhất**.
>3. **First-fit**: Chọn khối trống **đầu tiên** có thể cấp phát.
>4. **Next-fit**: Chọn khối trống **đầu tiên** có thể cấp phát **tính từ vị trí khối được cấp phát cuối cùng**.

# Cấp phát frame

OS phải quyết định cấp cho mỗi process bao nhiêu frame.
- Cấp ít frame -> nhiều page fault.
- Cấp nhiều frame -> Giảm mức độ multiprogramming.

Có 2 chiến lược cấp phát frame:
1. **Cấp phát tĩnh (fixed-allocation)**:
	- Số frame cấp cho mỗi process không đổi, được xác định vào thời điểm **loading (nạp process vào bộ nhớ)** và tùy thuộc vào từng ứng dụng (kích thước của nó,...).
	- Có 2 loại cấp phát tĩnh là : Cấp phát *theo tỷ lệ* và *theo độ ưu tiên*.

2. **Cấp phát động (variable-allocation)**:
	- Số frame cấp cho mỗi process có thể thay đổi trong khi nó chạy:
		- Nếu tỷ lệ page-fault *cao* -> cấp *thêm* frame.
		- Nếu tỷ lệ page-fault *thấp* -> giảm *bớt* frame.
	- => OS phải *mất chi phí* để ước định các process.

# Vấn đề Thrashing

## Thrashing

Thrashing là **hiện tượng máy tính dành phần lớn thời gian để hoán đổi trang (paging) giữa RAM và ổ đĩa**, thay vì thực thi chương trình.

Để hạn chế thrashing, OS phải cung cấp cho process càng "đủ" frame càng tốt.

Có 2 cách:

## Locality

- Locality là tập các trang được tham chiếu gần nhau.
- Một process gồm nhiều locality, và trong quá trình thực thi, process sẽ chuyển từ locality này sang locality khác.
Khi kích thước locality nhiều hơn RAM, thiếu frame, gây ra page-fault và thrashing.

## Working set

Working set tại thời điểm $t$ của process $i$ : $\text{WS}(t)_i$ là tập các trang mà process $i$ liên tục sử dụng trước $t$ một khoảng $\Delta$ thời gian, tức là **mới dùng gần đây**.

Working set có thể *xấp xỉ* locality.

Gọi:
- $D=\sum{|\text{WS}|}$, tức là tổng các trang mà toàn bộ hệ thống đang cần.
- $m$ là tổng số frame.

Khi đó:
- Nếu $D>m$ thì xảy ra thrashing, như đã nói ở trên.
- Khi đó, OS sẽ block một số process cho đến khi $D\leq m$. Khi block process $i$ thì $|\text{WS}_i|=0$.
