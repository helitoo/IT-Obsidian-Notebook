
```insta-toc
---
title:
  name: Mục lục
  level: 1
  center: false
exclude: ""
style:
  listType: number
omit: []
levels:
  min: 1
  max: 6
---

# Mục lục

1. Tổng quan
    1. Deadblock
    2. Điều kiện xảy ra deadblock
    3. Các phương pháp giải quyết deadlock
2. Mô hình hóa bài toán tắc nghẽn
    1. Đồ thị cấp phát tài nguyên - (Resource allocation graph, RAG)
    2. Giải thuật Banker
```


# Tổng quan

## Deadblock

**Deadblock** là hiện tượng có một tập các process bị block, mỗi process giữ một số tài nguyên và đang chờ thêm các tài nguyên khác mà các process khác trong tập đang giữ. Sự tắc nghẽn có thể diễn ra *vô hạn*.

## Điều kiện xảy ra deadblock

1. **Loại trừ tương hỗ**: ít nhất một tài nguyên được giữ theo nonsharable mode (không được dùng bởi nhiều process).
2. **Giữ và chờ cấp thêm tài nguyên**: Một process đang giữ ít nhất 1 tài nguyên và đợi thêm tài nguyên do process khác giữ. Các process nắm tài nguyên mà các process khác đang cần, tạo ra một **chu trình đợi**.
3. **Không trưng dụng**: Tài nguyên không thể bị lấy lại mà chỉ có thể được trả lại từ process đang giữ tài nguyên đó khi nó muốn.

## Các phương pháp giải quyết deadlock

---
**Ngăn deadblock**: Không cho phép (ít nhất) một trong 4 điều kiện cần cho deadlock.
1. **Ngăn mutual exclusion**:
	1. Đối với tài nguyên không chia sẻ (printer): không làm được.
	2. Đối với tài nguyên chia sẻ (read-only file): không cần thiết.
	
2. **Hold and wait**:
	1. Cách 1: Mỗi tiến trình yêu cầu toàn bộ tài nguyên cần thiết một lần. Nếu có đủ tài nguyên thì hệ thống sẽ cấp phát, nếu không đủ tài nguyên thì tiến trình phải bị block.
	2. Cách 2: Khi yêu cầu tài nguyên, tiến trình không được giữ tài nguyên nào. Nếu đang có thì phải trả lại trước khi yêu cầu.
	
3. **Ngăn no preemption**: nếu tiến trình A có giữ tài nguyên và đang yêu cầu tài nguyên khác nhưng tài nguyên này chưa được cấp phát ngay thì:
	1. Cách 1: Hệ thống lấy lại mọi tài nguyên mà A đang giữ. A chỉ bắt đầu lại được khi có được các tài nguyên đã bị lấy lại cùng với tài nguyên đang yêu cầu.
	2. Cách 2: Hệ thống sẽ xem tài nguyên mà A yêu cầu.
		1. Nếu tài nguyên được giữ bởi một tiến trình khác đang đợi thêm tài nguyên, tài nguyên này được hệ thống lấy lại và cấp phát cho A.
		2. Nếu tài nguyên được giữ bởi tiến trình không đợi tài nguyên, A phải đợi và tài nguyên của A bị lấy lại. Tuy nhiên hệ thống chỉ lấy lại các tài nguyên mà tiến trình khác yêu cầu.
	
4. **Ngăn chu trình đợi**: gán một thứ tự cho tất cả các tài nguyên trong hệ thống

---
**Tránh deadblock**: Các tiến trình cần cung cấp thông tin về tài nguyên nó cần để hệ thống cấp phát tài nguyên một cách thích hợp.
- Đảm bảo hiệu suất sử dụng tài nguyên tối đa đến mức có thể.
- Yêu cầu mỗi tiến trình khai báo số lượng tài nguyên tối đa cần để thực hiện công việc.
- Kiểm tra trạng thái cấp phát tài nguyên để đảm bảo hệ thống không rơi vào deadlock.
- Trạng thái cấp phát tài nguyên được định nghĩa dựa trên số tài nguyên còn lại, số tài nguyên đã được cấp phát và yêu cầu tối đa của các tiến trình.

---
**Cho phép hệ thống vào trạng thái deadlock, nhưng sau đó phát hiện deadlock và phục hồi hệ thống**.

---
**Bỏ qua mọi vấn đề, xem như deadlock không bao giờ xảy ra trong hệ thống**: Deadlock không được phát hiện, dẫn đến việc giảm hiệu suất của hệ thống. Cuối cùng, hệ thống có thể ngưng hoạt động và phải khởi động lại.

# Mô hình hóa bài toán tắc nghẽn

## Đồ thị cấp phát tài nguyên - (Resource allocation graph, RAG)

Là 1 đồ thị có hướng, với tập đỉnh $V$ và tập cạnh $E$.
- $V$ gồm 2 loại:
	- Tập process: $P=\{P_1,P_2,... , P_n\}$.
	- Tập tài nguyên: $R=\{R_1, R_2,...,R_n\}$.
- $E$ gồm 2 loại:
	- Process $P_i$ yêu cầu tài nguyên $R_j$: $P_i\rightarrow R_j$.
	- Tài nguyên $R_j$ đang bị giữ bởi process $P_i$: $R_j\rightarrow P_i$.

Số lượng process tối đa được quyền nắm giữ 1 tài nguyên được gọi là **số lượng instance**. Ký hiệu là chấm `.`.

**Nhận biết deadblock từ RAG**:
1. RAG không chứa chu trình -> Không có deadblock.
2. RAG có chu trình -> Có thể có deadblock:
	1. Mỗi tài nguyên trong chu trình chỉ có 1 thực thể -> Deadblock.
	2. Mỗi tài nguyên trong chu trình có nhiều thực thể -> Có thể có deadblock. Số lượng thực thể càng nhiều thì khả năng deadblock càng thấp.

**Chuỗi an toàn**: Là thứ tự thực thi các process sao cho không xảy ra deadblock.

## Giải thuật Banker

Yêu cầu các process phải khai báo $\text{Need}$ là lượng tài nguyên tối đa nó cần, OS dựa vào đây để cấp phát.
