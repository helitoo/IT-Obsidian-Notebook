
>[!note]
>- Ưu tiên các process cần ít tài nguyên nhất.
>- Một bài toán có thể có nhiều chuỗi an toàn.

# RAG

Cho 1 hệ thống có 4 tiến trình P1 đến P4 và 3 loại tài nguyên R1 (3), R2 (2) R3 (2). Trong đó:
- P1 giữ 1 R1 và yêu cầu 1 R2;
- P2 giữ 2 R2 và yêu cầu 1 R1;
- P3 giữ 1 R1 và yêu cầu 1 R2;
- P4 giữ 2 R3 và yêu cầu 1 R1.
Hãy:
- Vẽ đồ thị tài nguyên cho hệ thống này?
- Hệ thống có xảy ra deadblock không?
- Chỉ ra chuỗi an toàn? (nếu có)

![[rag.png]]

Hệ thống không xảy ra deablock, vì không có chu trình, hay vì tồn tại chuỗi an toàn trong hệ thống này.

Ta thấy:
- Hiện không thể cấp tài nguyên cho P1 vì R2 đã hết instance.
- Cấp cho P2 trước, giải phóng 2 R2 và 1 R1. Sau đó cấp 2 R2 cho P1, giải phóng 1 R1 và 1 R2. Còn P3, P4 cái nào cấp trước cũng được.

# Banker

>[!note]
>- $\text{Allocation}_i$: Lượng tài nguyên hiện đang cấp cho process $i$.
>- $\text{Max}_i$: Lượng tài nguyên tối đa mà process $i$ cần.
>- $\text{Need}_i=\text{Max}_i-\text{Allocation}_i$.
>- $\text{Available}_i$: Lượng tài nguyên hệ thống hiện có tài thời điểm xử lý process thứ $i$.

>[!note]
>Nếu $\text{Need}$ < $\text{Available}$ mà > $\text{Max}$ thì vẫn tính là **không hợp lệ, OS sẽ không đáp ứng**.

>[!caution]
>Ở dạng bài này, tài nguyên được biểu thị bằng vector $[v_0;v_1;...v_n]$. Trong đó $v_i$ là số lượng instance của tài nguyên thứ $i$.

>[!note] Các bước làm bài
>1. Tìm process $i$ có $\text{Need}_i\leq\text{Available}$ và $\text{Need}_i$ là **nhỏ nhất**.
>2. Cập nhật $\boxed{\text{Available}_i\;-=\text{Need}_i+\text{Allocation}_i}$. Đã giải quyết xong process $i$.

Cho 5 process P0, P1, ... , P4, và 3 loại tài nguyên \[10; 5; 7].
Cho sơ đồ cấp phát tại thời điểm $t_0$, tìm chuỗi an toàn:

|        | Allocation | Max        | Need       | Available  | Finish order |
| ------ | ---------- | ---------- | ---------- | ---------- | ------------ |
| **P0** | \[0; 1; 0] | \[7; 5; 3] | \[7; 4; 3] | \[3; 3; 2] |              |
| **P1** | \[2; 0; 0] | \[3; 2; 2] | \[1; 2; 2] |            |              |
| **P2** | \[3; 0; 2] | \[9; 0; 2] | \[6; 0; 0] |            |              |
| **P3** | \[2; 1; 1] | \[2; 2; 2] | \[0; 1; 1] |            |              |
| **P4** | \[0; 0; 2] | \[4; 3; 3] | \[4; 3; 1] |            |              |

Hiện tại ta không thể cấp thêm cho P0 vì P0 cần \[7; 4; 3], trong khi ta chỉ còn \[3; 3; 2]. Ta sẽ cấp cho P3 vì nó cần ít tài nguyên nhất:

|        | Max        | Need       | Available  | Finish order |
| ------ | ---------- | ---------- | ---------- | ------------ |
| **P0** | \[7; 5; 3] | \[7; 4; 3] | \[3; 3; 2] |              |
| **P1** | \[3; 2; 2] | \[1; 2; 2] |            |              |
| **P2** | \[9; 0; 2] | \[6; 0; 0] |            |              |
| **P3** | \[2; 2; 2] | \[0; 1; 1] | \[5; 4; 3] | 1            |
| **P4** | \[4; 3; 3] | \[4; 3; 1] |            |              |

Lúc này ta có thể cấp cho cả P1 hoặc P4 đều được, sau đó cấp cho P2 hoặc P0 đều được, hoàn thành bài toán.

|        | Max        | Need       | Available   | Finish order |
| ------ | ---------- | ---------- | ----------- | ------------ |
| **P0** | \[7; 5; 3] | \[7; 4; 3] | \[10; 5; 7] | 5            |
| **P1** | \[3; 2; 2] | \[1; 2; 2] | \[7; 4; 3]  | 2            |
| **P2** | \[9; 0; 2] | \[6; 0; 0] | \[10; 4; 7] | 4            |
| **P3** | \[2; 2; 2] | \[0; 1; 1] | \[5; 4; 3]  | 1            |
| **P4** | \[4; 3; 3] | \[4; 3; 1] | \[7; 4; 5]  | 3            |




