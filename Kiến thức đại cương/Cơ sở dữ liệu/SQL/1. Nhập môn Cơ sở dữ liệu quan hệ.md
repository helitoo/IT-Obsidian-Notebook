
```insta-toc
---
title:
  name: Mục lục
  level: 1
  center: false
exclude: ""
style:
  listType: number
omit: []
levels:
  min: 1
  max: 6
---

# Mục lục

1. Tổng quan về Cơ sở dữ liệu quan hệ
2. Ngôn ngữ mô tả dữ liệu
    1. Sơ đồ các lệnh định nghĩa dữ liệu (CREATE, ALTER, DROP)
    2. Khai báo constraint
    3. Các kiểu dữ liệu
    4. Các hàm đa dụng
    5. Biểu thức
3. Ngôn ngữ thao tác dữ liệu
    1. Thêm dữ liệu (INSERT INTO VALUES)
    2. Sửa dữ liệu (UPDATE SET WHERE)
    3. Xóa dữ liệu (DELETE FROM WHERE)
4. Ngôn ngữ truy vấn dữ liệu (SELECT)
    1. Object
    2. Các từ khóa hiệu chỉnh kết quả truy vấn
    3. Các phép toán quan hệ
```

# Tổng quan về Cơ sở dữ liệu quan hệ

**Cơ sở dữ liệu (Relational database, RDB)** là một loại cơ sở dữ liệu dựa trên [[2. Mô hình dữ liệu#Mô hình dữ liệu quan hệ (Relationship model)|mô hình quan hệ]]. Trong đó:
- Mỗi quan hệ là 1 bảng.
- Mỗi thuộc tính là 1 cột.
- Mỗi bộ là 1 hàng.

Trong bài này sử dụng cú pháp của **Microsoft SQL Server (MSSQL)**, các loại RDB khác cũng tương tự.

Một số quy tắc hoạt động:
- **Không cần** dấu `;` cuối câu, ngoại trừ một số lệnh đặc biệt.
- **Không phân biệt** chữ hoa, chữ thường.
- Các lệnh có thể được **chạy đồng thời**. Để phân biệt 1 lệnh trước chạy trước lệnh sau, gần thêm `GO` vào cuối lệnh trước.

>[!NOTE]
>Mô hình mô tả và thao tác có quy tắc: **Thao tác bảng được tham chiếu trước, bảng tham chiếu sau**.

# Ngôn ngữ mô tả dữ liệu

## Sơ đồ các lệnh định nghĩa dữ liệu (`CREATE`, `ALTER`, `DROP`)

- `CREATE`: Tạo:
	- `DATABASE dbName`.
	- `TABLE tbName (tbDeclairation)`.

- `ALTER TABLE tbName`:
	- `ADD CONSTRAINT ctName ctDeclairation...` (Đối với `UNIQUE`, `PRIMARY KEY`, `FOREIGN KEY`, `CHECK`).
	- `ADD colDeclairation`.
	- `ALTER COLUMN colName colType`: Đổi kiểu dữ liệu.
	- `DROP COLUMN colName`.
	- `DROP CONSTRAINT ctName`.

- `DROP`: Xóa:
	- `DATABSE dbName`.
	- `TABLE tbName`.

Trong đó:
- `tbDeclairation` có dạng `colDeclairation1, colDeclairation2, ...`.
- `colDeclairation` có dạng `colName type ct`.
- `ctDeclairation` là cú pháp khai báo constraints column-level.

Riêng đối với:
- `USE dbName`: Truy cập vào database. Chú ý lệnh này phải được chạy riêng với `CREATE DATABASE`.

## Khai báo constraint

Constraint là những ràng buộc về dữ liệu. Nếu dữ liệu chèn vào bảng không thỏa constraint thì thao tác đó không thành công.

Các constraint **mặc định sẽ chỉ ảnh hưởng lên 1 bảng**. Các constraint nâng cao có thể được xây dựng bằng [[2. Transact-SQL (T-SQL)#Trigger|Trigger]].

- **Khai báo constraints ngay trong khai báo cột (Column-level)**: Chỉ áp dụng cho 1 cột.
	- `NULL`: Cho phép dữ liệu trong 1 cột chứa `NULL`.
	- `NOT NULL`: Không cho phép dữ liệu trong 1 cột chứa `NULL`.
	- `UNIQUE`: Không cho phép dữ liệu trong 1 cột được trùng nhau.
	- `DEFAULT val`: Đặt `val` là giá trị mặc định trong cột này.
	- `CHECK (logicExp)`: Chỉ cho phép dữ liệu các cột thỏa mãn điều kiện `logicExp`.
	- `PRIMARY KEY`: Chỉ định trường này là primary key.
	- `FOREIGN KEY REFFERENCES tb(pcols)`.

- **Khai báo constrains ngay dưới khai báo bảng (Table-level)**: Có thể áp dụng tùy nghi nhiều cột và dễ chỉnh sửa sau khi khai báo,
	- Đối với `UNIQUE`, `PRIMARY KEY`, `CHECK`: `CONSTRAINT ctName ctType (cols)`.
	- Đối với `FOREIGN KEY`: `CONSTRAINT ctName FOREIGN KEY (cols) REFERENCES tb(pcols)`.

## Các kiểu dữ liệu

Các kiểu dữ liệu cũng là 1 loại ràng buộc.

---
**Kiểu logic**: `BIT` (0 - 1).

---
**Kiểu ký tự**:
1. `CHAR(n)`: Chuỗi không Unicode **cố định** `n` ký tự. Nếu dữ liệu đưa vào cột có kiểu `CHAR(n)` có độ dài không đủ `n` thì tự chèn thêm các khoảng trắng phía sau để bù vào.
2. `VARCHAR(n)`: Chuỗi không Unicode **tối đa** `n` ký tự.
3. `VARCHAR(TEXT)`: Chuỗi không Unicode dài **tối đa 2GB**.

Để lưu trữ ký tự Unicode, thêm tiền tố `N` phía trước tên kiểu dữ liệu.

VD:
- `NCHAR(n)`, `NVARCHAR(n)`, `NVARCHAR(TEXT)`.
- `N'Đang sản xuất'`.

>[!NOTE]
>- Ưu tiên `CHAR(n)` cho **ID**.
>- Ưu tiên `VARCHAR(100)` cho **tên riêng**.
>- Ưu tiên `VARCHAR(TEXT)` cho **văn bản dài**.

---
**Kiểu số**:
1. **Exact numeric**: Số nguyên.
	1. `INT` / `MONEY`: -2 tỷ -> 2 tỷ.
	2. `SMALLINT` / `SMALLMONEY`: -32000 -> 32000.
	3. `TINYINT`: 0 -> 255.

2. **Approxiate numeric**: Số thực.
	1. `DECIMAL(a,b)` hoặc `NUMERIC(a,b)`: Có tổng cộng `a` chữ số và có `b` chữ số phần thập phân.
	2. `FLOAT(n)`: Độ chính xác `n` chữ số phần thập phân.
	3. `REAL`: Là `FLOAT(24)`.

---
**Kiểu thời gian**:
1. `DATE`: Có dạng `'yyyy-mm-dd'`.
2. `TIME`: Có dạng `'hh:mm:ss.fffffff'`.
3. `DATETIME`: Có dạng `'yyyy-mm-dd hh:mm:ss.fffffff'`.

## Các hàm đa dụng

**Xử lý chuỗi**:
1. `LEN(s)`: Độ dài chuỗi.
2. `TRIM(s)`: Xóa khoảng trắng ở 2 đầu chuỗi.
3. `LEFT(s, n)`: Lấy `n` ký tự bên trái chuỗi.
4. `RIGHT(s, n)`: Lấy `n` ký tự bên phải chuỗi.

## Biểu thức

---
**Toán tử số học**: `+`, `-`, `*`, `/`, `%`.

---
**Toán tử so sánh**: `AND`, `OR`, `NOT`, `=`, `<>`, `>`, `>=`, `<`, `<=`.

---
**Toán tử `IS NULL` và `IS NOT NULL`**: Kiểm tra giá trị `NULL`. Giá trị này được trả về khi `SELECT` không tìm thấy hàng cần tìm.

---
**Toán tử `BETWEEN AND`**:
```sql
colName BETWEEN min AND max
```
Tương đương với `min <= colName AND colName <= max`.

---
**Toán tử `LIKE`**: Dùng đo so sánh gần chính xác chuỗi dựa trên một mẫu (pattern). Pattern cũng là 1 chuỗi, có 2 ký tự đặc biệt:
1. `_`: Tượng trưng cho 1 ký tự.
2. `%`: Tượng trưng cho chuỗi ký tự.
VD: `s LIKE '_a__'` trả về `TRUE` nếu `s` bắt đầu bằng 1 ký tự, sau đó là ký tự `a` và kết thúc bằng 2 ký tự.

---
**Toán tử `IN`**: Kiểm tra giá trị trong 1 tập hợp, có thể nằm trong bộ `()` hoặc `SELECT`.
```sql
colName IN (value1, value2,...)
colName IN SELECT... -- 1 cột
```
Trả về true nếu `colName` có giá trị thuộc `value1` hoặc `value2` hoặc ...

---
**Toán tử `EXISTS`**: Kiểm tra 1 tập hợp có rỗng không.
```sql
EXISTS tb
```
Trả về true nếu `tb` có nhiều hơn 1 cột, 1 hàng. `tb` ở đây thường dùng `SELECT 1` nếu là truy vấn.

---
**Toán tử `CASE`**:
```sql
CASE colName
    WHEN value1 THEN result1
    ...
    ELSE result_default
END
```
- Trả về từng `result` tương ứng với từng `value` của `colName`.
- Nếu khai báo `colName`, `value` là 1 hằng số, tức là so sánh từng giá trị của cột `colName` với `value`.
- Nếu không khai báo `colName`, `value` là 1 biểu thức logic bất kỳ.

# Ngôn ngữ thao tác dữ liệu

>[!CAUTION]
>Đối với các lệnh **xóa, sửa**, nếu không có mệnh đề `WHERE` thì sẽ thực hiện xóa, sửa **toàn bộ dữ liệu trong bảng**.

## Thêm dữ liệu (`INSERT INTO VALUES`)

```sql
INSERT INTO tbName (colNames)
VALUES
	(values1),
	(...)
```

>[!CAUTION]
>Nếu không khai báo `colNames`, mặc định các dữ liệu được thêm theo thứ tự cột khi khai báo bảng.

```sql
INSERT INTO tbName1 SELECT * FROM tbName2
SELECT * INTO tbName1 FROM tbName2
```
Chèn dữ liệu bảng `tbName2` vào bảng `tbName1`.

>[!CAUTION]
>Các cột của 2 bảng phải giống nhau.

## Sửa dữ liệu (`UPDATE SET WHERE`)

```sql
UPDATE tbName
SET col1 = val1,...
WHERE logicExp
```

```sql
UPDATE tbName
SET col1 = val1,...
SELECT...
```
Cập nhật dữ liệu từ bản tạm thu được từ `SELECT`.

```sql
UPDATE tbA
SET
	tbA.colA = tbB.colB,
	tbA.colB = tbB.colA
FROM (
	SELECT *
	FROM tbA
) AS tbB
WHERE tbA.id = tbB.id
```
Hoán đổi dữ liệu 2 cột.

## Xóa dữ liệu (`DELETE FROM WHERE`)

```sql
DELETE FROM tbName
WHERE logicExpt
```

# Ngôn ngữ truy vấn dữ liệu (`SELECT`)

`SELECT` chính là phép $\pi_\text{(object)}\text{table1}$ trong [[3. Mô hình quan hệ#Đại số quan hệ|Đại số quan hệ]].

Cấu trúc chung:
```sql
SELECT object AS name,...
DISTINCT
FROM table1
JOIN table2 ON logicExp
...
WHERE logicExp
GROUP BY cols,...
HAVING logicExp
ORDER BY col1 DESC/ASC, col2 DESC/ASC,...
LIMIT n
```

Kết quả của SELECT có 2 loại:

| Bảng $n \times m$    | Bảng $1 \times 1$                 |
| -------------------- | --------------------------------- |
| Có $n \times m$ ô.   | Có 1 ô.                           |
| Được coi như 1 bảng. | Được coi như một dữ liệu (value). |

## Object

Là những gì bạn mong muốn trích xuất ra từ table.
- Object có thể là cột, hàm hoặc một giá trị cụ thể.
- Khi object là `*`, SELECT sẽ lấy hết dữ liệu có thể.

## Các từ khóa hiệu chỉnh kết quả truy vấn

`DISTINCT`: Lọc ra các hàng trùng nhau, chỉ lấy các hàng độc nhất.

`ORDER BY col1 DESC/ASC`: Sắp xếp kết quả cột `col1` theo thứ tự giảm dần (`DESC`) hoặc tăng dần (`ASC`)

## Các phép toán quan hệ

---
**Chọn**: Chọn ra các bộ thỏa mãn điều kiện `logicExp`:
```sql
WHERE logicExp
```

---
**Chiếu**: Lấy ra các cột `col1`, `col2`,... trong bảng `tb`:
```sql
tb.col1, tb.col2,...
```

---
**Đổi tên**:
- Đối với bảng: `tb AS newTb`.
- Đối với cột: `col AS newCol`.

---
**Gộp nhóm**: Gộp các hàng có chung giá trị ở các cột `cols`, sau đó lọc giữ các nhóm thỏa điều kiện `HAVING`:
```sql
GROUP BY cols
HAVING logicExp
```

---
**Equi-join (Inner-join)**: Dựa trên cột `tbA.colA` và `tbB.colB`:
```sql
INNER JOIN tbB
ON tbA.colA = tbB.colB
```

---
**Natural-join**: Dựa trên cột `tbA.col = tbB.col`:
```sql
NATURAL JOIN tbB
```

---
**Left/Right/Full-Outer-Join**: Dựa trên cột `tbA.colA` và `tbB.colB`:
```sql
LEFT OUTER JOIN tb2
ON tbA.colA = tbB.colB
```

---
**Hội**: Ghép `tbA` với `tbB`:
```sql
tbA
UNION
tbB
```

---
**Giao**: Lấy ra những hàng xuất hiện ở cả `tbA` và `tbB`:
```sql
tbA
INTERSECT
tbB
```

---
**Trừ**: Lấy ra những hàng chỉ có ở `tbA` mà không có ở `tbB`:
```sql
tbA
EXCEPT
tbB
```

---
**Chia**: Lấy các hàng mà giá trị trong `colA` của `tbA` mà ứng với toàn bộ các giá trị trong `colB` của `tbB`.
```sql
SELECT tbA.colA
FROM tbA
WHERE tbA.colB IN (SELECT colB FROM tbB)
GROUP BY tbA.colA
HAVING COUNT(DISTINCT tbA.colB) = (SELECT COUNT(*) FROM tbB);
```
- Đầu tiên, gộp nhóm và đếm số lượng các `tbA.colB`.
























