
# Tổng quan về Cơ sở dữ liệu quan hệ

**Cơ sở dữ liệu (Relational database, RDB)** là một loại cơ sở dữ liệu dựa trên [[2. Mô hình dữ liệu#Mô hình dữ liệu quan hệ (Relationship model)|mô hình quan hệ]]. Trong đó:
- Mỗi quan hệ là 1 bảng.
- Mỗi thuộc tính là 1 cột.
- Mỗi bộ là 1 hàng.

Trong bài này sử dụng cú pháp của **Microsoft SQL Server (MSSQL)**, các loại RDB khác cũng tương tự.

Một số quy tắc hoạt động:
- **Không cần** dấu `;` cuối câu, ngoại trừ một số lệnh đặc biệt.
- **Không phân biệt** chữ hoa, chữ thường.
- Các lệnh có thể được **chạy đồng thời**. Để phân biệt 1 lệnh trước chạy trước lệnh sau, gần thêm `GO` vào cuối lệnh trước.

>[!NOTE]
>Mô hình mô tả và thao tác có quy tắc: **Thao tác bảng được tham chiếu trước, bảng tham chiếu sau**.

# Ngôn ngữ mô tả dữ liệu

## Sơ đồ các lệnh định nghĩa dữ liệu (`CREATE`, `ALTER`, `DROP`)

- **`CREATE`: Tạo / `OR REPLACE`: Tạo hoặc thay thế (nếu có)**:
	- `DATABASE dbName`.
	- `TABLE tbName (tbDeclairation)`.
	- `VIEW viewName AS SELECT...`.

- **`ALTER TABLE tbName`**:
	- `ADD CONSTRAINT ctName ctDeclairation...` (Đối với `UNIQUE`, `PRIMARY KEY`, `FOREIGN KEY`, `CHECK`).
	- `ADD colDeclairation`.
	- `ALTER COLUMN colName colType`: Đổi kiểu dữ liệu.
	- `DROP COLUMN colName`.
	- `DROP CONSTRAINT ctName`.

- **`DROP`: Xóa dữ liệu và cấu trúc**:
	- `DATABSE dbName`.
	- `TABLE tbName`.
	- `VIEW viewName`.

- **`TRUNCATE`: Xóa dữ liệu (no-logging)**:
	- `TABLE tbName`.

Trong đó:
- `tbDeclairation` có dạng `colDeclairation1, colDeclairation2, ...`.
- `colDeclairation` có dạng `colName type ct`.
- `ctDeclairation` là cú pháp khai báo constraints column-level.

Một vài cú pháp đặc biệt:
- `USE dbName`: Truy cập vào database. Chú ý lệnh này phải được chạy riêng với `CREATE DATABASE`.
- `EXEC sp_rename 'oldName', 'newName'`: Đổi tên.
- `SET IDENTITY_INSERT ON`: Cho phép chèn giá trị tùy nghi vào cột có constraint `IDENTITY`.

**View** là bảng tạm lưu tại RAM được xây dựng từ `SELECT`. Khi view được gọi, `SELECT` sẽ được thực thi tương ứng.

## Khai báo constraint

Constraint là những ràng buộc về dữ liệu. Nếu dữ liệu chèn vào bảng không thỏa constraint thì thao tác đó không thành công.

Các constraint **mặc định sẽ chỉ ảnh hưởng lên 1 bảng**. Các constraint nâng cao có thể được xây dựng bằng [[5. Lập trình thủ tục trong SQL#Trigger|Trigger]].

Các cách khai báo constraints:

**Khai báo constraints *ngay trong khai báo cột* (Column-level)**: Chỉ áp dụng cho 1 cột.
- `NULL`: Cho phép dữ liệu trong 1 cột chứa `NULL`.
- `NOT NULL`: Không cho phép dữ liệu trong 1 cột chứa `NULL`.
- `UNIQUE`: Không cho phép dữ liệu trong 1 cột được trùng nhau.
- `DEFAULT v`: Đặt `v` là giá trị mặc định trong cột này.
- `IDENTITY(start, step)`: Chỉ định giá trị mặc định của cột này là số nguyên và tăng dần từ `start` `step` đơn vị.
- `CHECK (logicExp)`: Chỉ cho phép dữ liệu các cột thỏa mãn điều kiện `logicExp`.
- `PRIMARY KEY`: Chỉ định trường này là primary key.
- `REFFERENCES tb(pcols)`: Chỉ định trường này là khóa ngoại tham chiếu đến `tb.pcols`.

**Khai báo constrains *ngay dưới khai báo bảng* (Table-level)**: Có thể áp dụng tùy nghi nhiều cột và dễ chỉnh sửa sau khi khai báo:
- Đối với `UNIQUE`, `PRIMARY KEY`, `CHECK`:
```sql
ctType (cols)
CONSTRAINT ctName ctType (cols)
```

- Đối với `FOREIGN KEY`:
```sql
FOREIGN KEY (cols) REFERENCES tb(pcols)
CONSTRAINT ctName FOREIGN KEY (cols) REFERENCES tb(pcols)
```

>[!NOTE]
>- Ngoại trừ `PRIMARY KEY` và `FOREIGN KEY`, việc khai báo column-level và table-level không khác nhau.
>- `PRIMARY KEY` và `FOREIGN KEY` khai báo ở table-level thì có thể **gom nhiều thuộc tính**.
>- Khai báo `CONSTRAINT ctName` chỉ áp dụng cho table-level và dùng khi cần quản lý thêm, sửa, xóa sau này. Vì `CONSTRAINT` chỉ thể `ADD`, `DROP` thông qua `ctName`.

>[!tip]
>Dạng mệnh đề **Nếu `A` thì `B`** có thể đưa về constraint: `CHECK(NOT (A) OR B)`

## Các kiểu dữ liệu và aggreeate function

| Kiểu dữ liệu                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Aggreeate function                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| - \[Oracle] `NUMBER(p, s)`: `p` chữ số phần nguyên (1 - 38), `s` chữ số phần thập phân (mặc định là *0*).<br><br>- \[MSSQL] `BIT`: `0`/`1`.<br><br>- \[MSSQL] `TINYINT`: 0 - 255.<br><br>- \[MSSQL] `INT`/`MONEY`: -2 tỷ - 2 tỷ.<br><br>- \[MSSQL] `SMALLINT`/`SMALLMONEY`: -32000 - 32000.<br><br>- \[MSSQL] `DECIMAL(a, b)`/`NUMERIC(a, b)`: Có tổng cộng `a` chữ số và có `b` chữ số phần thập phân.<br><br>- \[MSSQL] `REAL`: Là `FLOAT(24)`.<br><br>- `FLOAT(n)`: Độ chính xác `n` chữ số phần thập phân. | - `ABS(x)`: $\|x\|$.<br>- `CEIL(x)`: $\lceil x\rceil$.<br>- `FLOOR(x)`: $\lfloor x\rfloor$.<br>- `ROUND(x, d)`: Làm tròn `d` chữ số phần thập phân.<br>- `MOD(x, y)`: $x\;\%\;y$.<br>- `SQRT(x)`: $\sqrt{x}$.<br>- `POWER(x, y)`: $x^y$.<br>- `LOG(x)`: $\log{x}$.                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| - `CHAR(n)`: Chuỗi không Unicode **cố định** `n` ký tự. Nếu dữ liệu đưa vào cột có kiểu `CHAR(n)` có độ dài không đủ `n` thì tự chèn thêm các khoảng trắng phía sau để bù vào.<br><br>- \[MSSQL] `VARCHAR(n)`: Chuỗi không Unicode **tối đa** `n` ký tự.<br><br>- \[Oracle] `VARCHAR2(n)`: Như trên.<br><br>Để lưu trữ ký tự Unicode, thêm tiền tố `N` phía trước tên kiểu dữ liệu.                                                                                                                            | - \[MSSQL] `LEN(s)`.<br>- \[Oracle] `LENGTH(s)`.<br>  : Độ dài chuỗi.<br><br>- \[MSSQL] `SUBSTRING(s, a, b)`.<br>- \[Oracle] `SUBSTR(s, a, b)`.<br>  : Lấy chuỗi từ vị trí `a` đến `b`, 1-based.<br><br>- \[MSSQL] `LEFT(s, n)`: Lấy `n` ký tự bên trái chuỗi. Tương tự với `RIGHT`.<br><br>- `UPPER(s)`: In hoa chuỗi `s`. Tương tự với `LOWER`.<br><br>- `TRIM(s)`: Xóa khoảng trắng ở 2 đầu chuỗi.<br><br>- `CONCAT(a, b, c,...)`: Nối chuỗi.                                                                                                                                                                                                                                                                   |
| - `DATE`: `'yyyy-mm-dd'`.<br><br>- \[MSSQL] `TIME`: `'hh:mm:ss.fffffff'`.<br><br>- \[MSSQL] `DATETIME`.<br>- \[Oracle] `TIMESTAMP`.<br>  : `'yyyy-mm-dd hh:mm:ss.fffffff'`.                                                                                                                                                                                                                                                                                                                                    | - \[MSSQL] `NOW()`.<br>- \[Oracle] `SYSTIMESTAMP`.<br>  : Ngày-giờ hiện tại.<br><br>- \[MSSQL] `GETDATE()`.<br>- \[Oracle] `SYSDATE`.<br>  : Ngày hiện tại.<br><br>- \[Oracle] `EXTRACT (elm FROM d)`: Lấy ra `elm` từ `d`. `elm` có thể là `YEAR`, `MONTH`, `DAY`.<br><br>- \[MSSQL] `YEAR(d)`: Lấy năm của giá trị `d`. Tương tự với `MONTH(d)`, `DAY(d)`.<br><br>- \[MSSQL] `DATE_ADD(d, INTERVAL n unit)`: Thêm `n` `unit` vào `d`. `unit` có thể là `DAY`, `MONTH`, `YEAR`. Tương tự với `DATE_SUB(...)`.<br><br>- \[Oracle]: `d + n`: Thêm `n` ngày.<br><br>- \[Oracle]: `ADD_MONTHS(d, n)`: Thêm `n` tháng.<br><br>- \[MSSQL] `DATEDIFF(d1, d2)`.<br>- \[Oracle] `d1 - d2`<br>  : Số ngày giữa 2 thời điểm. |
| **Bảng dữ liệu**.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | - `COUNT(X)`: Số lượng hàng của cột `X`.<br><br>- `SUM(X)`: Tổng cột `X`. Tương tự với `AVG(X)`, `MIN(X)`, `MAX(X)`.<br><br>- \[MSSQL] `STRING_AGG(X, d)`: Trả về chuỗi chứa giá trị các hàng của cột `X` được nối nhau bằng chuỗi `d`.<br><br>- `COALESCE(X, v)`: Nếu `X` là `NULL` thì trả về `v`, không thì trả về giá trị `X` tương ứng.<br>                                                                                                                                                                                                                                                                                                                                                                   |

**Ép kiểu dữ liệu**:
- **MSSQL**: Tự nhận diện data type.
- **Oracle**:
	- **Chuyển sang datetime**: Dùng `TO_DATE(s, 'yyyy-mm-dd')` (*hoặc có thể đổi sang format khác*).
	- Tương tự với `TO_CHAR(v, format)`, `TO_CHAR(v)`, `TO_NUMBER(v)`.

## Biểu thức

---
**Toán tử số học**: `+`, `-`, `*`, `/`, `%`.

---
**Toán tử so sánh**: `AND`, `OR`, `NOT`, `=`, `<>` / `!=`, `>`, `>=`, `<`, `<=`.

---
**Toán tử `IS NULL` và `IS NOT NULL`**: Kiểm tra giá trị `NULL`. Giá trị này được trả về khi `SELECT` không tìm thấy hàng cần tìm.

---
**Toán tử `BETWEEN AND`**:
```sql
colName BETWEEN min AND max
```
Tương đương với `min <= colName AND colName <= max`.

---
**Toán tử `LIKE`**: Dùng đo so sánh gần chính xác chuỗi dựa trên một mẫu (pattern). Pattern cũng là 1 chuỗi, có 2 ký tự đặc biệt:
1. `_`: Tượng trưng cho 1 ký tự. Bạn có thể ghi các ký tự cụ thể vào đây.
2. `%`: Tượng trưng cho chuỗi ký tự.
VD: `s LIKE '_a__'` trả về `TRUE` nếu `s` bắt đầu bằng 1 ký tự, sau đó là ký tự `a` và kết thúc bằng 2 ký tự.

---
**Toán tử `IN`**: Kiểm tra giá trị trong 1 tập hợp, có thể nằm trong bộ `()` hoặc `SELECT` không.
```sql
colName IN (value1, value2,...)
colName IN SELECT... -- 1 cột
```
Trả về true nếu `colName` có giá trị thuộc `value1` hoặc `value2` hoặc ...

---
**Toán tử `EXISTS`**: Kiểm tra 1 tập hợp có rỗng không.
```sql
EXISTS tb
```
Trả về true nếu `tb` có nhiều hơn 1 cột, 1 hàng. `tb` ở đây thường dùng `SELECT 1` nếu là truy vấn.

Đôi khi, `IN` và `EXISTS` được dùng thay thế cho nhau.

---
**Toán tử `ANY`**: Tượng trưng cho một giá trị bất kỳ trong tập hợp.

VD:
```sql
SELECT HoTen
FROM NhanVien
WHERE Luong > ANY (
	SELECT Luong
	FROM NhanVien
	WHERE MaPB = 'PB01'
);
```
-> Trả về các nhân viên có lương lớn hơn **bất kỳ** nhân viên nào trong phòng ban `PB01`.

---
**Toán tử `ALL`**: Tượng trưng cho toàn bộ giá trị trong tập hợp.

VD:
```sql
SELECT HoTen
FROM NhanVien
WHERE Luong > ALL (
	SELECT Luong
	FROM NhanVien
	WHERE MaPB = 'PB01'
);
```
-> Trả về các nhân viên có lương lớn hơn **tất cả** nhân viên trong phòng ban `PB01`.

---
**Toán tử `CASE`**:
```sql
CASE colName
    WHEN value1 THEN result1
    ...
    ELSE result_default
END
```
- Trả về từng `result` tương ứng với từng `value` của `colName`.
- Nếu khai báo `colName`, `value` là 1 hằng số, tức là so sánh từng giá trị của cột `colName` với `value`.
- Nếu không khai báo `colName`, `value` là 1 biểu thức logic bất kỳ.
