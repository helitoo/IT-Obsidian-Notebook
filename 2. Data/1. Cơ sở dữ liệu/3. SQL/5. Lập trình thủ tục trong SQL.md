
Hầu hết hệ quản trị cơ sở dữ liệu quan hệ đều hỗ trợ lập trình như một phần mở rộng:
- Đối với MSSQL: **T-SQL** (*Transact-SQL*).
- Đối với Oracle: **PL/SQL** (*Procedural Language extensions to SQL*).

# Các cấu trúc logic đơn giản

## Biến

|              | T-SQL                                                                                                   | PL/SQL                                                                                                                                                                                                                                                                                                                          |
| ------------ | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Khai báo** | `DECLARE @var type = val;`                                                                              | **Biến số**:<br>`var TYPE;`<br><br>**Khai báo kiểu của biến là kiểu của 1 cột trong bảng**:<br>`var tb.col%TYPE;`<br><br>**Khai báo biến là 1 hàng của bảng**:<br>`var tb%ROWTYPE;` (*Lúc này, biến đóng vai trò như 1 struct chứa các trường ứng với các cột của bảng*)<br><br>**Hằng số**:<br>`varname CONSTANT TYPE := val;` |
| **Gán**      | **Gán giá trị đơn**:<br>`SET @var = val;`<br><br>**Gán bảng**:<br>`SELECT @var = colName ... FROM ...;` | **Gán giá trị đơn**:<br>`var := val;`<br><br>**Gán 1 hàng của bảng**:<br>`SELECT INTO var FROM ...`<br><br><br><br>                                                                                                                                                                                                             |
| **In**       | `PRINT val;`                                                                                            | `DBMS_OUTPUT.PUT_LINE(val);`                                                                                                                                                                                                                                                                                                    |

>[!CAUTION] Biến trong T-SQL
>- Biến được sử dụng với cú pháp `@varName` (có dấu `@` phía trước tên).
>- Biến không được lưu trữ lâu dài mà **chỉ tồn tại tại thời điểm thực thi**.

Không có ràng buộc gì cấu trúc chương trình T-SQL, kể cả việc viết dấu `;` cũng là không bắt buộc.

Trong PL/SQL có cú pháp nghiêm ngặt, phải có dấu `;`, chương trình gồm 3 phần:
```sql
[DECLARE]
    -- Khai báo biến, hằng, cursor, exception
BEGIN
    -- Chương trình chính
EXCEPTION
    -- Bắt và xử lý lỗi
END;
```

## Cấu trúc rẽ nhánh

#### If - else

\[T-SQL]:
```sql
IF logicExp
	-- Code block
ELSE
	-- Code block
```

\[Oracle]
```sql
IF logicExp THEN -- Code block
ELSE -- Code block
END IF;
```

\[Oracle]:
```sql
IF logicExp THEN -- Code block
ELSIF logicExp THEN -- Code block
END IF;
```

#### Case

\[T-SQL]
```sql
CASE var
	WHEN logicExp THEN res
	ELSE -- Code block
END
```

\[Oracle]
```sql
CASE [var]
	WHEN logicExp THEN res
	ELSE res
END;
```

## Cấu trúc lặp

#### While

\[T-SQL]
```sql
WHILE loopCond
BEGIN
	-- Code block
END
```

\[PL/SQL]
```sql
WHILE loopCond
LOOP
	-- Code block
END LOOP;
```

\[PL/SQL]
```sql
LOOP
	-- Code block
	IF stopCond THEN
		-- Code block
		EXIT;
	END IF;
END LOOP;
```

#### For

\[PL/SQL]
```sql
FOR i IN [REVERSE] startVal .. endVal
LOOP
	-- Code block
END LOOP;
```

\[PL/SQL]
```sql
FOR i IN [REVERSE] SELECT ... -- i là từng record của bảng
LOOP
	-- Code block
END LOOP;
```

# Cursor

Cursor được dùng như một con trỏ duyệt bảng.

Các lệnh `UPDATE`, `INSERT`, `SELECT`,... được thực thi bởi con trỏ, điều khiển bởi database engine. Trong bài viết này, ta sẽ tự tạo con trỏ cho riêng mình.

\[T-SQL]: Không khuyến khích dùng vì tốc độ kém.
```sql
-- Định nghĩa biến lưu giá trị từng cột
DECLARE @col1 datatype,
        @col2 datatype;

-- Định nghĩa cursor
DECLARE cs CURSOR FOR SELECT ...

-- Mở cursor
OPEN cs;

-- Lấy dòng đầu tiên
FETCH NEXT FROM cs INTO @col1, @col2;

-- Duyệt
WHILE @@FETCH_STATUS = 0
BEGIN
    -- Code block
    
    -- Lấy dòng tiếp theo
    FETCH NEXT FROM cs INTO @col1, @col2;
END;

-- Đóng cursor
CLOSE cs;

-- Giải phóng bộ nhớ cursor
DEALLOCATE cs;
```

\[PL/SQL]: **Dạng đầy đủ**:
```sql
DECLARE
	-- Định nghĩa cursor
	CURSOR cs IS SELECT ...
	
	-- Định nghĩa biến lưu giá trị từng cột
	col1 tb.col1%TYPE;
	col2 tb.col2%TYPE;
BEGIN
	-- Mở cursor
	OPEN cs;
	
	-- Duyệt
	LOOP
		-- Lấy dữ liệu từng dòng
		FETCH cs INTO col1, col2;
		-- FETCH cs INTO record;
		
		-- Ngưng duyệt
		EXIT WHEN cs%NOTFOUND;
		
		-- Code block
	END LOOP;
	
	-- Đóng cursor
	CLOSE cs;
END;
```

\[PL/SQL]: **Dạng thu gọn**:
```sql
BEGIN
	FOR cs IN SELECT ...
	LOOP
		-- Code block
		-- Dữ liệu được lưu trong cs.col1, cs.col2
	END LOOP;
END;
```

\[PL/SQL]: **Một số thuộc tính của cursor**:
- `cs%NOTFOUND`: Không tìm thấy dữ liệu.
- `cs%ROWCOUNT`: Số dòng đã được fetch.

\[PL/SQL]: **Con trỏ có tham số**: Dùng cho SQL injection:

# Chương trình con

Thủ tục và hàm là những đoạn code **được lưu trữ lâu dài**, có thể sử dụng nhiều lần.

Thủ tục không trả về giá trị, hàm thì không.

## Stored procedure

#### Khai báo

\[T-SQL]
```sql
CREATE [OR REPLACE] PROCEDURE p
@var1 TYPE1,
@var2 TYPE2
AS
BEGIN
	-- Code block
END
```
Gọi: `EXEC p param1 param2`.

\[PL/SQL]
```sql
CREATE [OR REPLACE] PROCEDURE p (
	param1 IN TYPE,
	param2 OUT TYPE
)
IS
BEGIN
	-- Code block
	-- EXCEPTION ...
END;
```
Gọi: `p(param1, param2)`.

Thủ tục trong PL/SQL có 3 loại:
- `IN` (mặc định):
	Có giá trị ban đầu và không thể bị thay đổi trong thủ tục.
	-> Dùng để nạp dữ liệu vào thủ tục.
- `OUT`:
	Không có giá trị ban đầu và phải bị thay đổi trong thủ tục.
	-> Dùng để lấy dữ liệu từ thủ tục.
- `IN OUT`:
	Có giá trị ban đầu và phải bị thay đổi trong thủ tục.

## Function

\[T-SQL]: **Normal function**:
```sql
CREATE FUNCTION dbo.f (@param1 TYPE)
RETURNS TYPE
AS
BEGIN
	-- Code block
	RETURN val
END
```
Gọi: `dbo.f(param1)`.

\[T-SQL]: **Scalar function**:
```sql
CREATE FUNCTION dbo.f (@param1 TYPE)
RETURNS TABLE
AS
BEGIN
	-- Code block
	RETURN val
END
```
Gọi: `dbo.f(param1)`.

\[PL/SQL]
```sql
CREATE FUNCTION f (param TYPE)
RETURN TYPE
IS
BEGIN
	-- Code block
	RETURN val
END
```
Gọi: `f(param)`.

## Trigger

Trigger là một **stored procedure** được **gọi tự động** khi dữ liệu bị thay đổi (*Thêm, Sửa, Xóa*).

Có 2 loại trigger:
- `BEFORE` (Mặc định): Thực thi trước khi thao tác lên dữ liệu.
- `AFTER`: Thực thi sau khi thao tác lên dữ liệu.

#### Trong T-SQL

```sql
CREATE OR ALTER TRIGGER tg
ON tb
[INSTEAD OF]
INSERT--, UPDATE, DELETE
AS
BEGIN
    -- Code block
END;
```

Khi một trigger diễn ra, SQL tự động cung cấp 2 **bảng ảo** có cấu trúc giống bảng bị thao tác:

| Bảng \ Sự kiện | `INSERT`           | `DELETE`                  | `UPDATE`                              |
| -------------- | ------------------ | ------------------------- | ------------------------------------- |
| `INSERTED`     | Chứa các hàng mới. | Rỗng.                     | Chứa các giá trị mới.                 |
| `DELETED`      | Rỗng.              | Chứa các hàng sắp bị xóa. | Chứa các giá trị cũ, sắp bị thay thế. |

Lệnh ngăn sự kiện xảy ra: Sử dụng 1 trong 3 lệnh:
- `ROLLBACK`.
- `ROLLBACK TRAN`.
- `ROLLBACK TRANSACTION`.
Sau lệnh trên, trigger sẽ ngừng thực thi.

>[!tip]
>- Hạn chế dùng `NOT EXISTS` điều kiện đúng, **nên dùng `EXISTS` điều kiện sai** vì nó tự nhiên hơn, tránh các lỗi logic.
>- Hạn chế dùng `DECLARE` vì nó có thể bị lỗi khi người dùng thao tác trên nhiều dòng cùng lúc (`DELETED` và `INSERTED` có nhiều dòng).

>[!important]
>Sau khi kiểm tra dữ liệu và thấy dữ liệu sai, trigger có 2 thao tác:
>- **`ROLLBACK TRAN`** \[Ưu tiên]: Ngăn chặn thêm/sửa dữ liệu.
>- **`UPDATE SET WHERE`**: Sửa lại dữ liệu cho đúng.

VD: `INSTEAD OF` xử lý `INSERT` trên view:
```sql
CREATE TABLE departments (
    dept_id CHAR(3) PRIMARY KEY,
    dept_name VARCHAR(50)
);

CREATE TABLE employees (
    emp_id CHAR(3) PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id CHAR(3) REFERENCES departments(dept_id)
);

-- View không thể được INSERT
-- mà chỉ có thể INSERT từ các bảng tạo thành view
CREATE VIEW v_emp_dept AS
SELECT e.emp_id, e.emp_name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;

-- Xử lý INSERT trên view
CREATE OR ALTER TRIGGER trg_v_emp_dept_ins
ON v_emp_dept
INSTEAD OF INSERT
AS
BEGIN
    INSERT INTO employees(emp_id, emp_name, dept_id)
    SELECT 
        i.emp_id,
        i.emp_name,
        d.dept_id
    FROM inserted i
    JOIN departments d
        ON d.dept_name = i.dept_name;
END;
```

VD: Chặn thêm dữ liệu:
```sql
CREATE OR ALTER TRIGGER trg_no_negative_qty
ON orders
AFTER INSERT, UPDATE
AS
BEGIN
    IF EXISTS (
        SELECT 1
        FROM inserted
        WHERE quantity < 0
    )
    BEGIN
        THROW 50001, N'So luong khong hop le', 1;
        ROLLBACK TRANSACTION;
    END
END;
```

VD: Sửa dữ liệu trước khi thêm:
```sql
CREATE OR ALTER TRIGGER trg_before_insert_orders
ON orders
INSTEAD OF INSERT
AS
BEGIN
    INSERT INTO orders(order_id, quantity, cost_per_item, total_cost)
    SELECT
        i.order_id,
        i.quantity,
        i.cost_per_item,
        ISNULL(i.total_cost, i.quantity * i.cost_per_item)
    FROM inserted i;
END;
```

VD: Cho phép thêm dữ liệu:
```sql
CREATE OR ALTER TRIGGER orders_after_insert
ON orders
AFTER INSERT
AS
BEGIN
    INSERT INTO orders_audit (
        order_id,
        quantity,
        cost_per_item,
        total_cost,
        username
    )
    SELECT
        i.order_id,
        i.quantity,
        i.cost_per_item,
        i.total_cost,
        SYSTEM_USER
    FROM inserted i;
END;
```

#### Trong PL/SQL

```sql
CREATE [OR REPLACE] TRIGGER tg
[INSTEAD OF] [BEFORE -- hoặc AFTER]
INSERT -- OR UPDATE OR DELETE
ON tb
FOR EACH ROW
BEGIN
    -- Code block
END;

```

Trong đó:
- `INSTEAD OF`: Kích hoạt khi schema của bảng thay đổi.
- `FOR EACH ROW` là trigger mức dòng, dùng để kiểm soát dữ liệu vào / ra table.
	- `:OLD`: Dữ liệu cũ, chỉ có thể sửa đổi trong `BEFORE DELETE`.
	- `:NEW`: Dữ liệu mới, chỉ có thể sửa đổi trong `BEFORE` `INSERT` / `UPDATE`.
	- `RAISE_APPLICATION_ERROR(-20001, 'msg');`: Ném ra lỗi, ngăn thao tác xảy ra.

VD: `INSTEAD OF` xử lý `INSERT` trên view:
```sql
CREATE TABLE departments (
    dept_id NUMBER PRIMARY KEY,
    dept_name VARCHAR2(50)
);

CREATE TABLE employees (
    emp_id NUMBER PRIMARY KEY,
    emp_name VARCHAR2(50),
    dept_id NUMBER REFERENCES departments(dept_id)
);

-- View không thể được INSERT
-- mà chỉ có thể INSERT từ các bảng tạo thành view
CREATE VIEW v_emp_dept AS
SELECT e.emp_id, e.emp_name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;

-- Xử lý INSERT trên view
CREATE OR REPLACE TRIGGER trg_v_emp_dept_ins
INSTEAD OF INSERT ON v_emp_dept
FOR EACH ROW
DECLARE
    v_dept_id NUMBER;
BEGIN
    -- Tìm dept_id từ dept_name
    SELECT dept_id
    INTO v_dept_id
    FROM departments
    WHERE dept_name = :NEW.dept_name;
	
	-- Cập nhật
    INSERT INTO employees(emp_id, emp_name, dept_id)
    VALUES (:NEW.emp_id, :NEW.emp_name, v_dept_id);
END;
```

VD: Chặn thêm dữ liệu:
```sql
CREATE OR REPLACE TRIGGER trg_no_negative_qty
BEFORE INSERT OR UPDATE ON orders
FOR EACH ROW
BEGIN
    IF :NEW.quantity < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'So luong khong hop le');
    END IF;
END;
```

VD: Sửa dữ liệu trước khi thêm:
```sql
CREATE OR REPLACE TRIGGER trg_before_insert_orders
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
    -- Nếu total_cost chưa được set thì tự tính
    IF :NEW.total_cost IS NULL THEN
        :NEW.total_cost := :NEW.quantity * :NEW.cost_per_item;
    END IF;
END;

```

VD: Cho phép thêm dữ liệu:
```sql
CREATE OR REPLACE TRIGGER orders_after_insert
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    INSERT INTO orders_audit (
        order_id,
        quantity,
        cost_per_item,
        total_cost,
        username
    )
    VALUES (
        :NEW.order_id,
        :NEW.quantity,
        :NEW.cost_per_item,
        :NEW.total_cost,
        USER
    );
END;
```

## Cấu trúc bắt lỗi

\[T-SQL]
```sql
BEGIN TRY
	-- Code block
END TRY
BEGIN CATCH
	-- Code block
END CATCH
```

\[PL/SQL] Chỉ có 1 lần bắt lỗi trên toàn bộ chương trình bằng cú pháp:
```sql
EXCEPTION
	WHEN error1 THEN -- Code block
	WHEN error2 THEN -- Code block
	-- ...
```

Một số `error`:
- `CURSOR_ALREADY_OPEN`: Mở một cursor vốn đã được mở rồi.
- `INVALID_CURSOR`: Mở một cursor mà chưa được tạo.
- `DUP_VAL_ON_INDEX`: Thao tác vi phạm ràng buộc `UNIQUE`.
- `VALUE_ERROR`: Thao tác vi phạm ràng buộc hoặc lỗi ép kiểu.
- `INVALID_NUMBER`: Lỗi ép kiểu sang `NUMBER`.
- `ZERO_DIVIDE`: Lỗi chia cho `0`.
- `LOGIN_DENIED`: Sai thông tin đăng nhập.
- `NOT_LOGGED_ON`: Muốn xử lý lên database mà chưa đăng nhập.
- `NO_DATA_FOUND`: `SELECT INTO` không có dữ liệu.
- `TOO_MANY_ROWS`: `SELECT INTO` có nhiều hơn 2 record.
- `PROGRAM_ERROR`: Lỗi do lập trình.
- `STORAGE_ERROR`: Lỗi do bộ nhớ.
- `TIMEOUT_ON_RESOURCE`: Timeout.
- `OTHERS`: Lỗi khác.
