
`SELECT` chính là phép $\pi_\text{(object)}\text{table1}$ trong [[3. Mô hình quan hệ#Đại số quan hệ|Đại số quan hệ]].

Cấu trúc chung:
```sql
SELECT 
TOP n (WITH TIES)
DISTINCT
object AS name,...
FROM table1
JOIN table2 ON logicExp
...
WHERE logicExp
GROUP BY cols,...
HAVING logicExp
ORDER BY col1 DESC/ASC, col2 DESC/ASC,...
LIMIT n
```

Kết quả của SELECT có 2 loại:

| Bảng $n \times m$    | Bảng $1 \times 1$                 |
| -------------------- | --------------------------------- |
| Có $n \times m$ ô.   | Có 1 ô.                           |
| Được coi như 1 bảng. | Được coi như một dữ liệu (value). |

# Object

Là những gì bạn mong muốn trích xuất ra từ table.
- Object có thể là cột, hàm hoặc một giá trị cụ thể.
- Khi object là `*`, SELECT sẽ lấy hết dữ liệu có thể.

# Các từ khóa hiệu chỉnh kết quả truy vấn

1. `TOP n`: Chỉ lấy ra `n` *hàng* đầu tiên của bảng.
2. `TOP n WITH TIES`: Lấy ra `n` *hạng* đầu tiên. Mỗi hạng bao gồm một số hàng có giá trị giống nhau.
3. `DISTINCT`: Lọc bỏ các hàng trùng nhau, chỉ lấy các hàng độc nhất.
4. `ORDER BY col1 DESC/ASC`: Sắp xếp kết quả cột `col1` theo thứ tự giảm dần (`DESC`) hoặc tăng dần (`ASC`). Nếu không ghi gì thì là `ASC`.

**Để lấy ra giá trị cao thứ n thì sao?**
- Cao thứ 1: Dùng `MAX`, `ORDER BY` + `TOP 1`.
- Cao thứ 2:
	- Flexible: Trả về giá trị cao thứ 2 nếu có thể: Lấy ra `TOP 2` giảm dần, rồi đảo ngược thứ tự để đưa `TOP 2` lên `TOP 1`.
	- Fixed: Trả về `NULL` nếu không có top 2: Lấy ra `MAX(X)` khi `X` thậm chí < một `MAX` khác.

VD: Flexible:
```sql
SELECT TOP 1 salary
FROM (
    SELECT TOP 2 salary
    FROM Employee
    ORDER BY salary DESC
) t
ORDER BY salary ASC;
```

VD: Fixed:
```sql
SELECT MAX(salary)
FROM Employee
WHERE salary < ALL (
	SELECT MAX(salary)
	FROM Employee
)
```

>[!note]
>Các hàm `MIN()`, `MAX()` có thể được thay bằng `SELECT TOP` và `ORDER BY ...`.

# Các phép toán quan hệ

## Phép chiếu (`.`)

Lấy ra các cột `col1`, `col2`,... trong bảng `tb`:
```sql
tb.col1, tb.col2,...
```

## Phép đổi tên (`AS`)

- Đối với bảng: `tb AS newTb`.
- Đối với cột: `col AS newCol`.

>[!NOTE]
>Có thể bỏ từ khóa `AS`.

## Phép chọn (`WHERE`)

Chọn ra các bộ thỏa mãn điều kiện `logicExp`:
```sql
WHERE logicExp
```

## Phép gộp nhóm (`GROUP BY HAVING`)

Gộp các hàng có chung giá trị ở các cột `cols`, sau đó lọc giữ các nhóm thỏa điều kiện `HAVING`:
```sql
GROUP BY cols
HAVING logicExp
```

>[!NOTE]
>- Những thuộc tính được `SELECT` phải được `GROUP BY`.
>- Áp dụng aggreeate function với các thuộc tính `GROUP BY` là vô nghĩa vì nó sẽ chỉ trả về đúng giá trị của từng ô trong thuộc tính đó, không có ý nghĩa thống kê.
>- `HAVING` chỉ dùng cho các nhóm sau khi `GROUP BY`, tức là dùng `HAVING` chung với các agreeate function.

## Phép kết (`JOIN`)

**Kết bằng (`JOIN` / `INNER JOIN`)**: Dựa trên cột `tbA.colA` và `tbB.colB`:
```sql
INNER JOIN tbB
ON tbA.colA = tbB.colB
```

**Kết ngoại (`LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`)**: Dựa trên cột `tbA.colA` và `tbB.colB`:
```sql
LEFT OUTER JOIN tb2
ON tbA.colA = tbB.colB
```
Tương tự với `RIGHT JOIN`.

>[!note]
>Chú ý **xét ưu tiên `LEFT JOIN`** trước `JOIN` vì `LEFT JOIN` xét cả những trường hợp không có khóa ngoại nào của bảng bên phải ứng với bảng bên trái.

## Phép hợp, giao, hội (`UNION`, `UNION ALL`, `INTERSECT`, `EXCEPT`)

Ghép `tbA` với `tbB`, loại bỏ các hàng bị trùng:
```sql
tbA
UNION
tbB
```

Ghép `tbA` với `tbB`:
```sql
tbA
UNION ALL
tbB
```

Lấy ra những hàng xuất hiện ở cả `tbA` và `tbB`:
```sql
tbA
INTERSECT
tbB
```

Lấy ra những hàng chỉ có ở `tbA` mà không có ở `tbB`:
```sql
tbA
EXCEPT
tbB
```

>[!important]
>- Không cần `SELECT` bảng được tạo ra bởi các phép trên.
>- Khi dùng các phép trên, trong nội bộ mỗi bảng thành phần không được `GROUP BY`, `ORDER BY`. Muốn dùng thì phải `SELECT` lồng 2 lần.

VD1: Không cần `SELECT` bảng được tạo ra bởi các phép trên.
```sql
-- Không cần SELECT ở đây nữa
SELECT id FROM A
UNION
SELECT id FROM B;
```

VD2: Khi dùng các phép trên, trong nội bộ mỗi bảng thành phần không được `GROUP BY`, `ORDER BY`. Muốn dùng thì phải `SELECT` lồng 2 lần.
```sql
SELECT id -- Phải bọc thêm 1 lớp SELECT ngoài ORDER BY
FROM (
    SELECT id
    FROM A
    ORDER BY id
) a -- Buộc phải có alias vì là subquery

UNION

SELECT id
FROM B;
```

>[!note]
>Trong nhiều trường hợp, các phép `UNION`, `INTERSECT` và `EXCEPT` có thể thay bằng **`EXISTS`, `NOT IN` và `LEFT JOIN`**.
