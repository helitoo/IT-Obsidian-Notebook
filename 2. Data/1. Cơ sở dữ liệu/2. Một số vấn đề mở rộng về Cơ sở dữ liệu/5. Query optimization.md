
**Tài liệu tham khảo**:
1. https://viblo.asia/p/query-optimization-techniques-in-sql-server-1-the-basics-4dbZNXEk5YM.
2. https://www.youtube.com/watch?v=aRkidzUZ-gg&t=485s

>[!quote]
>Khối lượng dữ liệu không quyết định thời gian thực thi.
>**Chiến lược thực thi** mới quyết định thời gian thực thi.

# Quy trình thực hiện truy vấn của SQL

Mọi truy vấn đều tuân theo cùng một quy trình cơ bản từ T-SQL đến khi hoàn thành việc thực thi trên SQL Server:

1. **Parsing**: Kiểm tra cú pháp truy vấn.
2. **Binding**: Kiểm tra tất cả các đối tượng được tham chiếu trong TQL của bạn so với danh mục hệ thống và bất kỳ đối tượng tạm thời nào được xác định trong code của bạn để xác định xem chúng có hợp lệ và được tham chiếu chính xác hay không.
3. **Optimization (CBO - Cost-based optimization)**:
	- Chọn chiến lược thực thi truy vấn tối ưu nhất.
	- *Chiến lược thực thi* là tập hợp các bước cụ thể mà công cụ thực thi sẽ tuân theo để xử lý một truy vấn. Mọi truy vấn đều có nhiều lựa chọn để đạt được kế hoạch thực thi đó và phải thực hiện trong một khoảng thời gian rất ngắn.
	- Mỗi chiến lược sẽ đánh giá bằng một đại lượng *cost*. Tùy từng engine mà cost được đánh giá khác nhau.
4. **Execution**: SQL Server nhận chiến lược thực thi và làm theo các hướng dẫn đó.

# Các vấn đề trong optimization

Ngoài những phép tối ưu về mặt Toán học (*Đại số quan hệ*), bài viết này sẽ chỉ nói về các tối ưu về mặt *engine*.

## Index scan

**Index** là một cấu trúc dữ liệu bổ trợ cho việc truy vấn dữ liệu, thay vì phải brute-force với độ phức tạp $O(n)$. Index thường được xây dựng bằng *B tree hoặc B+ tree*.
- Cả B tree và B+ tree đều là những cây tìm kiếm tự cân bằng với tốc độ thêm, sửa, xóa dữ liệu $O(\log n)$.
- Điểm khác nhau:

|           | B tree                                                                                                                                                                     | B+ tree                                                                                                                                           |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
|           | ![](https://media.geeksforgeeks.org/wp-content/uploads/20191219160544/Untitled-Diagram111.png)                                                                             | ![](https://media.geeksforgeeks.org/wp-content/uploads/Btree.jpg)                                                                                 |
| **Mô tả** | Dữ liệu được lưu tại bất kỳ đâu.<br><br>Ở một số biến thể, toàn bộ các nút đều không chứa dữ liệu mà chỉ chứa pointer trỏ đến dữ liệu gốc. Đôi khi có thể nhẹ hơn B+ tree. | Dữ liệu chỉ được lưu tại các leaf.<br>Các leaf thật chất là 1 linked list được liên kết với nhau.<br><br>Rất thích hợp để tìm kiếm `BETWEEN AND`. |

Khi tạo index trên cột nào, thì các giá trị của cột đó sẽ được chuyển thành khóa.

Ngoài B tree và B+ tree, còn có một số cấu trúc dữ liệu khác cũng được dùng làm index nhưng không phổ biến.

VD:
\[*MSSS*]
```sql
CREATE INDEX idx_user_name_age ON users(name, age);
-- Tạo index cho cột name, age
```

Chú ý rằng không phải lúc nào thì index cũng mang lại hiệu năng cao hơn. Dù có index nhưng cost kém thì SQL Server vẫn không chọn index scan (**skip index scan**).

Ví dụ về một số trường hợp index bị skip:

| Ví dụ               | Lý do                                                                                                             | Cách sửa            |
| ------------------- | ----------------------------------------------------------------------------------------------------------------- | ------------------- |
| `LEFT(name, 'Bao')` | Giả sử cột `name` có index, nhưng index này sẽ bị skip vì hàm `LEFT` đã biến đổi cột này rồi, index mất tác dụng. | `name LIKE 'Bao%'`  |
| `price + tax > 100` | Giả sử cột `price` hay `tax` có index, nhưng index này sẽ bị skip vì tổ hợp `price + tax` chưa có index.          | `price > 100 - tax` |

## Reuse plan

Hãy xem xét ví dụ sau:

\[*Orcle*]
```sql
FOR i IN 1..200000 LOOP
	EXECUTE IMMEDIATE '
		SELECT COUNT(*)
		FROM users
		WHERE id = ' || i
	INTO result
END LOOP
```

Như đã giải thích quy trình Optimization, lệnh trên đã tạo ra 200000 query khác nhau, ở mỗi query, Oracle đều phải tính toán chiến lược thực thi, mặc dù bản chất các query chỉ khác nhau ở điều kiện lọc.

\[*Orcle*]
```sql
FOR i IN 1..200000 LOOP
	EXECUTE IMMEDIATE '
		SELECT COUNT(*)
		FROM users
		WHERE id = :bl'
	INTO result
	USING i;
END LOOP
```
Thoạt nhìn có vẻ cũng tương tự lệnh trên, nhưng thật chất khác nhau hẳn vì đoạn code này chỉ tạo ra *1 query duy nhất* với biến `bl`, Oracle chỉ phân tích query này 1 lần, sau đó tuần tự thay giá trị `i` vào.

**Plan reuse**:
- Optimization là một quá trình vốn dĩ rất tốn kém, SQL Server duy trì một bộ đệm chứa thông tin về từng truy vấn được thực thi trên máy chủ và chiến lược đã được chọn cho nó.
- Khi một truy vấn được thực hiện mà đã có một kế hoạch hợp lệ trong bộ nhớ cache, thì kế hoạch đó sẽ được chọn ngay.

## Page / Block


































