
**Tài liệu tham khảo**:
- https://www.kaggle.com/learn/time-series.

# Tổng quan

**Chuỗi thời gian (Timeseries)** là một chuỗi các điểm dữ liệu xảy ra theo thứ tự liên tiếp trong một khoảng thời gian (*Regular timeinterval*).

Về mặt features, timeseries có 2 feature sau:
- **Time feature**: Dòng thời gian. Dòng thời gian liên tục là **Time dummy**, thường được tượng trưng bởi index cho dễ xử lý.
- **Lag feature**: Dịch giá trị tại mỗi mốc thời gian lên phía trước vài mốc. Trong một dataset có thể có nhiều lag feature với độ dịch khác nhau (*dịch 1 mốc, 2 mốc,... thời gian*). Các lag feature cung cấp cho model cái nhìn toàn cảnh (*giá trị ở hiện tại + những giá trị trong quá khứ*), qua đó nâng cao độ chính xác.

**Timeseries có 2 dạng**:
1. **Stationary**: Trend ổn định theo thời gian.
2. **Non-stationary**: Ngược lại.

![](https://www.researchgate.net/publication/372517696/figure/fig2/AS:11431281176093922@1690016354016/Stationary-and-non-stationary-time-series-A-time-series-stationary-or-non-stationary.png)

Chỉ có dữ liệu stationary mới khả thi để phân tích.

**Có 2 loại Stationary timeseries**:

| --                   | Time dependency                                                                                                             | Serial dependency                                                                                                       |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| **Định nghĩa**       | Giá trị phụ thuộc vào thời gian.                                                                                            | Giá trị tại một thời điểm phụ thuộc vào các giá trị trước đó.                                                           |
| **Thành phần chính** | **Trend**: Xu hướng tổng thể của dữ liệu.<br><br>**Seasonality**: Sự lặp đi lặp lại của dữ liệu trong một khoảng thời gian. | **Trend**: Xu hướng tổng thể của dữ liệu.<br><br>**Cycle**: Sự lặp đi lặp lại của dữ liệu mà không tuân theo thời gian. |

# Phân tích các thành phần của timeseries

## Trend

#### Moving average plot (SMA & EMA)

**Moving average plot** là trung bình cộng giá trị các cửa sổ trượt. Giá trị mỗi cửa sổ trượt là *trung bình cộng* các điểm trong cửa sổ đó.
Moving average giúp loại bỏ các trend nhất thời, chỉ thể hiện các trend dài hạn (*tùy vào kích thước cửa sổ*).

Còn một biến thể nữa của moving average plot, đó là thay vì lấy trung bình cộng (**SMA**), ta sẽ lấy *trung bình cộng có hệ số là thời gian*, các điểm càng nằm xa tâm của cửa sổ sẽ được đánh hệ số thấp hơn. Phương pháp SMA sẽ hiệu quả hơn EMA khi tiếp xúc với các time dependency timeserires.

| **Trung bình mượt đơn (SMA)**<br>                                                                                                   | **Trung bình mượt cấp số nhân (EMA)**                                                                                                                                                  |
| ----------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| $$\text{SMA}_t=\frac{1}{n}\sum_{i=t-n}^tx_i$$<br>	![](https://machinelearningcoban.com/tabml_book/_images/timeseries_data_17_0.png) | $$\text{EMA}_t=\alpha+x_t+(1-\alpha).\text{EMA}_{t-1}$$Trong đó:<br>$$\alpha=\frac{2}{n+1}$$<br>	<br>![](https://machinelearningcoban.com/tabml_book/_images/timeseries_data_19_0.png) |

**VD**: Dựa vào biểu đồ *Mauna Loa CO2* này, những trend biến động nhất thời (*trong tình huống này là seasonality*) bị lược bỏ đi, kết quả prediction cho thấy một trend lớn hơn: ppm có xu hướng tăng dần theo thời gian.
![](https://storage.googleapis.com/kaggle-media/learn/images/EZOXiPs.gif)

Ví dụ với *Tunel traffic*:
```python
# Calc moving avg
moving_average = tunnel.rolling(
    window=365,       # 365-day window
    center=True,      # puts the average at the center of the window
    min_periods=183,  # often is about half the window size
).mean()              # compute the mean (could also do median, std, min, max, ...)

# Plot
ax = tunnel.plot(style=".", color="0.5")
moving_average.plot(
    ax=ax, linewidth=3, title="Tunnel Traffic - 365-Day Moving Average", legend=False,
);
```

![[tunel-traffic-moving-avg.png]]

#### Deterministic processing

`statsmodels.tsa.deterministic.DeterministicProcess` là một phương pháp hiệu chỉnh training set hiệu quả, giúp model nhận diện được tính chu kỳ của thời gian. Có một vài tham số quan trọng như sau:
- `constant`: Nếu là `True` sẽ sinh ra *intercept (hệ số tự do)* của trend.
- `drop`: Nếu là `True` thì sẽ loại bỏ các feature có tính chất *đa cộng tuyến (Multicollinearity)*. Một feature có tính chất đa cộng tuyến thì nó hoàn toàn có thể được suy ra từ các feature khác, không mang lại điều gì mới cho dataset. Các cột này vừa tốn không gian, vừa làm nhiễu model.
- `order`: Bậc của trend, xác định bằng *moving average*.
- `period`: Số record nằm trong 1 season.
- `seasonal`: Tạo ra các feature thể hiện season của timeseries.

Trong đó, để hiệu chỉnh được các tham số trên, ta phải xem xét hình dạng trend (*SMA, PMA*) cùng với các kỹ thuật phân tích season.

```python
from statsmodels.tsa.deterministic import DeterministicProcess

dp = DeterministicProcess(
    index=tunnel.index,  # DATES from the training data
    constant=True,       # Add bias
    order=1,             # ORDER OF TREND (1 = linear, 2 = quadratic, ...)
    drop=True,           # drop terms if necessary to avoid collinearity
    # preriod=20,        # season's size
    # seasonal=True,     # seasonality
)
# `in_sample` creates features for the dates given in the `index` argument
X = dp.in_sample()

X.head()
```

| --         | const | trend |
| ---------- | ----- | ----- |
| Day        |       |       |
| 2003-11-01 | 1.0   | 1.0   |
| 2003-11-02 | 1.0   | 2.0   |
| 2003-11-03 | 1.0   | 3.0   |
| 2003-11-04 | 1.0   | 4.0   |
| 2003-11-05 | 1.0   | 5.0   |

Dùng phương thức có sẵn của `DeterministicProcess` để dự đoán thêm 1 khoảng thời gian trong tương lai:
```python
X = dp.out_of_sample(steps=30)

y_fore = pd.Series(model.predict(X), index=X.index)
```

![[tunel-traffic-out-of-sample.png]]

Predict bằng linear model (chú ý `fit_intercept`):

```python
from sklearn.linear_model import LinearRegression

y = tunnel["NumVehicles"]  # the target

# The intercept is the same as the `const` feature from
# DeterministicProcess. LinearRegression behaves badly with duplicated
# features, so we need to be sure to exclude it here.
model = LinearRegression(fit_intercept=False)
model.fit(X, y)

y_pred = pd.Series(model.predict(X), index=X.index)
```

![[tunel-traffic-linear-trend.png]]

## Lag features

**Lag features** có thể giúp nhận diện cả seasonality và cycle.

Ký hiệu *lag n* là dịch lên trước *n* mốc thời gian.

Không phải chọn càng nhiều lag càng tốt, vì:
- Phình to dữ liệu, giảm hiệu năng, thậm chí làm nhiễu model.
- Các lag sau có thể được suy ra từ các lag trước (*Multicollinearity, Đa cộng tuyến*), cực kỳ lãng phí.

Kỹ thuật **tính tự tương quan một phần (Partial autocorrelation / Correlogram)** cho phép nhìn thấy sự tương quan của một lag với các lag trước nó, cũng tức là thể hiện tầm quan trọng của 1 lag (Lag càng quan trọng thì càng ít tương quan với các lag phía trước).

Xét biểu đồ này, ta thấy từ lag 1 đến lag 6 gần như không tương quan gì đến nhau (độ tương quan nằm ngoài vùng an toàn được đánh dấu), nên ta sẽ chọn các lag này làm feature.
![](https://storage.googleapis.com/kaggle-media/learn/images/6nTe94E.png)


**VD: Time dependency timeseries**: Cho dataset *Tunnel traffic* ghi nhận số lượng phương tiện lưu thông qua Baregg Tunnel từ 11/2003 đến 11/2005.

Khảo sát dataset:
```python
df = tunnel.copy()
df['Time'] = np.arange(len(tunnel.index)) # Time dummy
df.head()
```

| --         | NumVehicles | Time |
| ---------- | ----------- | ---- |
| Day        |             |      |
| 2003-11-01 | 103536      | 0    |
| 2003-11-02 | 92051       | 1    |
| 2003-11-03 | 100795      | 2    |
| 2003-11-04 | 102352      | 3    |
| 2003-11-05 | 106569      | 4    |

Dùng `.arrange` (*sinh dãy số tăng dần*) là một cách làm sơ khai khi triển khai time dummy. Để nhận diện các vấn đề như trend, seasonality,... phải dùng các phương pháp mã hóa mạnh hơn, như `DeterministicProcess` (giới thiệu sau).

Dùng Linear model:
```python
from sklearn.linear_model import LinearRegression

# Training data
X = df[['Time']]  # features
y = df['NumVehicles']  # target

# Train the model
model = LinearRegression()
model.fit(X, y)

# Store the fitted values as a time series with the same time index as
# the training data
y_pred = pd.Series(model.predict(X), index=X.index)
```

![[tunel-traffic-linear-regression.png]]
Ta thấy hiện model có underfit khá lớn do model chỉ thấy được lượng phương tiện tại một thời điểm, không thấy được bức tranh toàn cảnh.

Thử dùng lag feature dịch `NumVehicles` tiến về phía trước 1 mốc thời gian (*`.shift(1)`*).
```python
df['Lag_1'] = df['NumVehicles'].shift(1)
df.head()
```

| --         | NumVehicles | Time | Lag_1    |
| ---------- | ----------- | ---- | -------- |
| Day        |             |      |          |
| 2003-11-01 | 103536      | 0    | NaN      |
| 2003-11-02 | 92051       | 1    | 103536.0 |
| 2003-11-03 | 100795      | 2    | 92051.0  |
| 2003-11-04 | 102352      | 3    | 100795.0 |
| 2003-11-05 | 106569      | 4    | 102352.0 |

```python
from sklearn.linear_model import LinearRegression

X = df[['Lag_1']].dropna()
y = df['NumVehicles']  # create the target
y, X = y.align(X, join='inner')  # drop corresponding values in target

model = LinearRegression()
model.fit(X, y)

y_pred = pd.Series(model.predict(X), index=X.index) # Keep original time dummy
```

![[tunel-traffic-linear-regression-with-lag.png]]

Ta thấy model đã dự đoán tốt hơn, nhận diện được các feature ngữ nghĩa của dataset, đỡ underfit.

**VD: Serial timeseries**: Cho dataset *Flu trends* ghi nhận số lần bệnh nhân đến khám bác sĩ vì bị cảm (*flu*) từ năm 2009 đến 2016.

![[flu-trends.png]]
Timeserires này không time dependency, bởi vì đỉnh điểm số lần khám bác sĩ khác nhau ở mỗi giai đoạn, đôi khi là đầu năm, đôi khi là giữa năm, kể cả số lượng cũng khác nhau. Đây là serial dependency.

Kiểm tra tương quan giữa các lag:
```python
from statsmodels.graphics.tsaplots import plot_pacf

plot_pacf(flu_trends.FluVisits, lags=12)
```

![[flu-trends-lags.png]]

Ta chọn các lag từ 1 đến 4 làm feature.

```python
def make_lags(ts, lags):
    return pd.concat(
        {
            f'y_lag_{i}': ts.shift(i)
            for i in range(1, lags + 1)
        },
        axis=1)

X = make_lags(flu_trends.FluVisits, lags=4)
X = X.fillna(0.0)
```

![[flu-trends-prediction.png]]
Kết quả khá tốt, nhưng có một chút sai số. Đây là một trong những hạn chế của lagging. Để cải thiện chất lượng model, ta có thể dùng thêm **leading features**. Leading feature là các feature có nhiệm vụ bổ trợ, cảnh báo sớm về cycle cho model.

Trong trường hợp này, ta sẽ dùng dữ liệu của *Google trends* về số lượt tìm kiếm từ khóa *flu* và các từ khóa liên quan (`FluCough`) để làm leading feature.

![[flu-trends-leading-feature.png]]

## Seasonality

#### Seasonal plots

**Seasonal plots** là vẽ chồng đồ thị các khoảng thời gian nhỏ lên nhau. Khi đó, bằng mắt thường rất dễ để biết là có seasonal hay không, và seasonal như thế nào.

![](https://storage.googleapis.com/kaggle-media/learn/images/bd7D4NJ.png)

#### Seasonal indicators

**Seasonal indicators** thực chất là mã hóa time feature thành các one-hot vectors. Nghe có vẻ đơn giản nhưng cách làm này rất tường minh và giúp model dễ dàng nhận diện seasonality trong dataset hơn.

**VD**: Chuyển `Date` (`datetime`) sang các one-hot vectors, mỗi vector ứng với 1 ngày trong tuần.

| Date       | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday |
| ---------- | ------- | --------- | -------- | ------ | -------- | ------ |
| 2016-01-04 | 0.0     | 0.0       | 0.0      | 0.0    | 0.0      | 0.0    |
| 2016-01-05 | 1.0     | 0.0       | 0.0      | 0.0    | 0.0      | 0.0    |
| 2016-01-06 | 0.0     | 1.0       | 0.0      | 0.0    | 0.0      | 0.0    |
| 2016-01-07 | 0.0     | 0.0       | 1.0      | 0.0    | 0.0      | 0.0    |
| 2016-01-08 | 0.0     | 0.0       | 0.0      | 1.0    | 0.0      | 0.0    |
| 2016-01-09 | 0.0     | 0.0       | 0.0      | 0.0    | 1.0      | 0.0    |
| 2016-01-10 | 0.0     | 0.0       | 0.0      | 0.0    | 0.0      | 1.0    |
| 2016-01-11 | 0.0     | 0.0       | 0.0      | 0.0    | 0.0      | 0.0    |
| ...        | ...     | ...       | ...      | ...    | ...      | ...    |

Kết quả dự đoán của model nếu có seasonal indicator (màu đen):
![](https://storage.googleapis.com/kaggle-media/learn/images/hIlF5j5.png)

#### Fourier features

**Fourier features** là một giải pháp chuẩn hóa dataset bên cạnh *Seasonal indicators*.

Thực tế dữ liệu có thể lên xuống 1 lần/năm, 2 lần/năm, 3 lần/năm,... (*Frequency*, $f$).
- Mỗi Fourier feature là một cặp $(\sin{2\pi ft};\;\cos{2\pi ft})$.
- Trong đó, $f$ càng cao thì Fourier càng thể hiện cụ thể seasonality. $f=0$, Fourier thể hiện seasonality một cách tổng thể nhất.

*Seasonal indicators* có thể cần đến hàng trăm one-hot vector, trong khi mỗi Fourier features chỉ cần 2 cột là $\sin$ và $\cos$. Thế nhưng, cần bao nhiêu cặp Fourier features là đủ?

**VD**:

| Dữ liệu thật                                                              | Fourier features                                                                                                                                                                                                                                                                                                                                                                |
| ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![](https://storage.googleapis.com/kaggle-media/learn/images/NJcaEdI.png) | ![](https://storage.googleapis.com/kaggle-media/learn/images/bKOjdU7.png)<br>- **Hình trên**: $f=1$.<br>- **Hình dưới**: $f=2$.                                                                                                                                                                                                                                                 |
|                                                                           | ![](https://storage.googleapis.com/kaggle-media/learn/images/mijPhko.png)<br>- **Hình trên**: Gồm có 4 cặp Fourier, mỗi cặp được biểu diễn bằng một đường cong có hàm số là tổng của 2 hàm $\sin$ và $\cos$ của mỗi cặp (*Được nội suy từ Linear model, để minh họa là chính chứ thực tế không có bước này*).<br>- **Hình dưới**: Tổng của 4 cặp Fourier trên (*Linear model*). |

#### Periodogram

**Periodogram** là biểu đồ thể hiện độ mạnh - yếu của các mức tần suất. Dùng để:
- Chọn lựa chiến lược *Seasonal indicators* hay *Fourier*.
- Nếu là *Fourier*, Periodogram cũng cho biết nên chọn bao nhiêu cặp Fourier.

**VD**: Trong biểu đồ dưới:
- Có thể thấy ở mức *Quarterly* ($f=4$) có độ mạnh khá lớn, nên ta chọn 4 cặp Fourier từ 1 đến 4.
- Và ta lại thấy mức *Weekly* lại càng mạnh hơn nữa, có thể được chuẩn hóa bằng *Sesonal indicators* vì nó chỉ có 7 one-hot vectors ứng với 7 ngày trong tuần.

Vậy, nên chọn *Sesonal indicators* theo tuần đối với bài toán này.

![](https://storage.googleapis.com/kaggle-media/learn/images/PK6WEe3.png)

## Noises & Hyprid model

Linear model có thể ngoại suy rất tốt, nhưng kém nhận diện các hiệu ứng xảy ra trong timeseries, hoàn toàn dựa vào các feature có sẵn. XGBoost thì ngược lại. Giải pháp đề ra là tạo ra một hyprid model kết hợp ưu điểm 2 loại model trên.

Một timeseries bao gồm 4 thành phần (một số tài liệu ghi là 3), gồm: Trend, Season, Cycle, Error.

Một model dự đoán timeseries tốt phải học được thông tin từ cả 4 thành phần trên. Hyprid model là loại model kết hợp mà đối với từng component, sẽ dùng từng loại model riêng để train và predict. Kết quả cuối cùng là tổng hợp kết quả của các model con thành phần.


![](https://storage.googleapis.com/kaggle-media/learn/images/XGJuheO.png)

**Quy trình xử lý**:
- Tách các thành phần Trend và Season / Cycle ra khỏi dataset gốc, tạo thành `X` (phương thức `DeterministicProcess` đã hỗ trợ sẵn việc cấu hình `X`). Dùng linear model predict (`X`, `y`).
- Lấy **residual** là phần chênh lệch giữa giá trị thực của timeseries với `y_res`: `y_res = y - p_pred`, lagging và dùng XGBoost model để predict (`X_lagged`, `y_res`).
- Tổng hợp kết quả cuối cùng: `y_final = y_1 + y_2`.

**Residual** là bao gồm thông tin về các noise, rất thích hợp với XGBoost.

![](https://storage.googleapis.com/kaggle-media/learn/images/mIeeaBD.png)
